{"id":"../node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/FileAudioSource.js","dependencies":[{"name":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/FileAudioSource.js.map","includedInParent":true,"mtime":1733074701821},{"name":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/package.json","includedInParent":true,"mtime":1733076065657},{"name":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/package.json","includedInParent":true,"mtime":1733074701821},{"name":"../common.speech/Exports","loc":{"line":42,"column":24,"index":2703},"parent":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/FileAudioSource.js","resolved":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js"},{"name":"../common/Exports","loc":{"line":43,"column":24,"index":2756},"parent":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/FileAudioSource.js","resolved":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js"},{"name":"../sdk/Audio/AudioStreamFormat","loc":{"line":44,"column":34,"index":2812},"parent":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/FileAudioSource.js","resolved":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioStreamFormat.js"}],"generated":{"js":"\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FileAudioSource = void 0;\nvar Exports_1 = require(\"../common.speech/Exports\");\nvar Exports_2 = require(\"../common/Exports\");\nvar AudioStreamFormat_1 = require(\"../sdk/Audio/AudioStreamFormat\");\nvar FileAudioSource = /** @class */ (function () {\n    function FileAudioSource(file, filename, audioSourceId) {\n        this.privStreams = {};\n        this.privHeaderEnd = 44;\n        this.privId = audioSourceId ? audioSourceId : Exports_2.createNoDashGuid();\n        this.privEvents = new Exports_2.EventSource();\n        this.privSource = file;\n        if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && this.privSource instanceof Blob) {\n            this.privFilename = file.name;\n        }\n        else {\n            this.privFilename = filename || \"unknown.wav\";\n        }\n        // Read the header.\n        this.privAudioFormatPromise = this.readHeader();\n    }\n    Object.defineProperty(FileAudioSource.prototype, \"format\", {\n        get: function () {\n            return this.privAudioFormatPromise;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(FileAudioSource.prototype, \"blob\", {\n        get: function () {\n            return Promise.resolve(this.privSource);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    FileAudioSource.prototype.turnOn = function () {\n        if (this.privFilename.lastIndexOf(\".wav\") !== this.privFilename.length - 4) {\n            var errorMsg = this.privFilename + \" is not supported. Only WAVE files are allowed at the moment.\";\n            this.onEvent(new Exports_2.AudioSourceErrorEvent(errorMsg, \"\"));\n            return Promise.reject(errorMsg);\n        }\n        this.onEvent(new Exports_2.AudioSourceInitializingEvent(this.privId)); // no stream id\n        this.onEvent(new Exports_2.AudioSourceReadyEvent(this.privId));\n        return;\n    };\n    FileAudioSource.prototype.id = function () {\n        return this.privId;\n    };\n    FileAudioSource.prototype.attach = function (audioNodeId) {\n        return __awaiter(this, void 0, void 0, function () {\n            var stream;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.onEvent(new Exports_2.AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\n                        return [4 /*yield*/, this.upload(audioNodeId)];\n                    case 1:\n                        stream = _a.sent();\n                        this.onEvent(new Exports_2.AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\n                        return [2 /*return*/, Promise.resolve({\n                                detach: function () { return __awaiter(_this, void 0, void 0, function () {\n                                    return __generator(this, function (_a) {\n                                        switch (_a.label) {\n                                            case 0:\n                                                stream.readEnded();\n                                                delete this.privStreams[audioNodeId];\n                                                this.onEvent(new Exports_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n                                                return [4 /*yield*/, this.turnOff()];\n                                            case 1:\n                                                _a.sent();\n                                                return [2 /*return*/];\n                                        }\n                                    });\n                                }); },\n                                id: function () { return audioNodeId; },\n                                read: function () { return stream.read(); },\n                            })];\n                }\n            });\n        });\n    };\n    FileAudioSource.prototype.detach = function (audioNodeId) {\n        if (audioNodeId && this.privStreams[audioNodeId]) {\n            this.privStreams[audioNodeId].close();\n            delete this.privStreams[audioNodeId];\n            this.onEvent(new Exports_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n        }\n    };\n    FileAudioSource.prototype.turnOff = function () {\n        for (var streamId in this.privStreams) {\n            if (streamId) {\n                var stream = this.privStreams[streamId];\n                if (stream && !stream.isClosed) {\n                    stream.close();\n                }\n            }\n        }\n        this.onEvent(new Exports_2.AudioSourceOffEvent(this.privId)); // no stream now\n        return Promise.resolve();\n    };\n    Object.defineProperty(FileAudioSource.prototype, \"events\", {\n        get: function () {\n            return this.privEvents;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(FileAudioSource.prototype, \"deviceInfo\", {\n        get: function () {\n            return this.privAudioFormatPromise.then(function (result) { return (Promise.resolve({\n                bitspersample: result.bitsPerSample,\n                channelcount: result.channels,\n                connectivity: Exports_1.connectivity.Unknown,\n                manufacturer: \"Speech SDK\",\n                model: \"File\",\n                samplerate: result.samplesPerSec,\n                type: Exports_1.type.File,\n            })); });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    FileAudioSource.prototype.readHeader = function () {\n        var _this = this;\n        // Read the wave header.\n        var maxHeaderSize = 512;\n        var header = this.privSource.slice(0, maxHeaderSize);\n        var headerResult = new Exports_2.Deferred();\n        var processHeader = function (header) {\n            var view = new DataView(header);\n            var getWord = function (index) { return String.fromCharCode(view.getUint8(index), view.getUint8(index + 1), view.getUint8(index + 2), view.getUint8(index + 3)); };\n            // RIFF 4 bytes.\n            if (\"RIFF\" !== getWord(0)) {\n                headerResult.reject(\"Invalid WAV header in file, RIFF was not found\");\n                return;\n            }\n            // length, 4 bytes\n            // RIFF Type & fmt 8 bytes\n            if (\"WAVE\" !== getWord(8) || \"fmt \" !== getWord(12)) {\n                headerResult.reject(\"Invalid WAV header in file, WAVEfmt was not found\");\n                return;\n            }\n            var formatSize = view.getInt32(16, true);\n            var channelCount = view.getUint16(22, true);\n            var sampleRate = view.getUint32(24, true);\n            var bitsPerSample = view.getUint16(34, true);\n            // Confirm if header is 44 bytes long.\n            var pos = 36 + Math.max(formatSize - 16, 0);\n            for (; getWord(pos) !== \"data\"; pos += 2) {\n                if (pos > maxHeaderSize - 8) {\n                    headerResult.reject(\"Invalid WAV header in file, data block was not found\");\n                    return;\n                }\n            }\n            _this.privHeaderEnd = pos + 8;\n            headerResult.resolve(AudioStreamFormat_1.AudioStreamFormat.getWaveFormatPCM(sampleRate, bitsPerSample, channelCount));\n        };\n        if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && header instanceof Blob) {\n            var reader = new FileReader();\n            reader.onload = function (event) {\n                var header = event.target.result;\n                processHeader(header);\n            };\n            reader.readAsArrayBuffer(header);\n        }\n        else {\n            var h = header;\n            processHeader(h.buffer.slice(h.byteOffset, h.byteOffset + h.byteLength));\n        }\n        return headerResult.promise;\n    };\n    FileAudioSource.prototype.upload = function (audioNodeId) {\n        return __awaiter(this, void 0, void 0, function () {\n            var onerror, format, stream_1, chunk, processFile_1, reader, c, e_1;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        onerror = function (error) {\n                            var errorMsg = \"Error occurred while processing '\" + _this.privFilename + \"'. \" + error;\n                            _this.onEvent(new Exports_2.AudioStreamNodeErrorEvent(_this.privId, audioNodeId, errorMsg));\n                            throw new Error(errorMsg);\n                        };\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 4, , 5]);\n                        return [4 /*yield*/, this.turnOn()];\n                    case 2:\n                        _a.sent();\n                        return [4 /*yield*/, this.privAudioFormatPromise];\n                    case 3:\n                        format = _a.sent();\n                        stream_1 = new Exports_2.ChunkedArrayBufferStream(format.avgBytesPerSec / 10, audioNodeId);\n                        this.privStreams[audioNodeId] = stream_1;\n                        chunk = this.privSource.slice(this.privHeaderEnd);\n                        processFile_1 = function (buff) {\n                            if (stream_1.isClosed) {\n                                return; // output stream was closed (somebody called TurnOff). We're done here.\n                            }\n                            stream_1.writeStreamChunk({\n                                buffer: buff,\n                                isEnd: false,\n                                timeReceived: Date.now(),\n                            });\n                            stream_1.close();\n                        };\n                        if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && chunk instanceof Blob) {\n                            reader = new FileReader();\n                            reader.onerror = function (ev) { return onerror(ev.toString()); };\n                            reader.onload = function (event) {\n                                var fileBuffer = event.target.result;\n                                processFile_1(fileBuffer);\n                            };\n                            reader.readAsArrayBuffer(chunk);\n                        }\n                        else {\n                            c = chunk;\n                            processFile_1(c.buffer.slice(c.byteOffset, c.byteOffset + c.byteLength));\n                        }\n                        return [2 /*return*/, stream_1];\n                    case 4:\n                        e_1 = _a.sent();\n                        onerror(e_1);\n                        return [3 /*break*/, 5];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    FileAudioSource.prototype.onEvent = function (event) {\n        this.privEvents.onEvent(event);\n        Exports_2.Events.instance.onEvent(event);\n    };\n    return FileAudioSource;\n}());\nexports.FileAudioSource = FileAudioSource;\n\n\n"},"sourceMaps":{"js":{"version":3,"sources":["src/common.browser/FileAudioSource.ts"],"names":[],"mappings":"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","file":"FileAudioSource.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    connectivity,\r\n    ISpeechConfigAudioDevice,\r\n    type,\r\n} from \"../common.speech/Exports\";\r\nimport {\r\n    AudioSourceErrorEvent,\r\n    AudioSourceEvent,\r\n    AudioSourceInitializingEvent,\r\n    AudioSourceOffEvent,\r\n    AudioSourceReadyEvent,\r\n    AudioStreamNodeAttachedEvent,\r\n    AudioStreamNodeAttachingEvent,\r\n    AudioStreamNodeDetachedEvent,\r\n    AudioStreamNodeErrorEvent,\r\n    ChunkedArrayBufferStream,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    Events,\r\n    EventSource,\r\n    IAudioSource,\r\n    IAudioStreamNode,\r\n    IStreamChunk,\r\n    IStringDictionary,\r\n    Stream,\r\n} from \"../common/Exports\";\r\nimport { AudioStreamFormat, AudioStreamFormatImpl } from \"../sdk/Audio/AudioStreamFormat\";\r\n\r\nexport class FileAudioSource implements IAudioSource {\r\n\r\n    private privAudioFormatPromise: Promise<AudioStreamFormatImpl>;\r\n\r\n    private privStreams: IStringDictionary<Stream<ArrayBuffer>> = {};\r\n\r\n    private privId: string;\r\n\r\n    private privEvents: EventSource<AudioSourceEvent>;\r\n\r\n    private privSource: Blob | Buffer;\r\n\r\n    private privFilename: string;\r\n\r\n    private privHeaderEnd: number = 44;\r\n\r\n    public constructor(file: File | Buffer, filename?: string, audioSourceId?: string) {\r\n        this.privId = audioSourceId ? audioSourceId : createNoDashGuid();\r\n        this.privEvents = new EventSource<AudioSourceEvent>();\r\n        this.privSource = file;\r\n        if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && this.privSource instanceof Blob) {\r\n            this.privFilename = (file as File).name;\r\n        } else {\r\n            this.privFilename = filename || \"unknown.wav\";\r\n        }\r\n\r\n        // Read the header.\r\n        this.privAudioFormatPromise = this.readHeader();\r\n    }\r\n\r\n    public get format(): Promise<AudioStreamFormatImpl> {\r\n        return this.privAudioFormatPromise;\r\n    }\r\n\r\n    public get blob(): Promise<Blob | Buffer> {\r\n        return Promise.resolve(this.privSource);\r\n    }\r\n\r\n    public turnOn(): Promise<void> {\r\n        if (this.privFilename.lastIndexOf(\".wav\") !== this.privFilename.length - 4) {\r\n            const errorMsg = this.privFilename + \" is not supported. Only WAVE files are allowed at the moment.\";\r\n            this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\"));\r\n            return Promise.reject(errorMsg);\r\n        }\r\n\r\n        this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\r\n        this.onEvent(new AudioSourceReadyEvent(this.privId));\r\n        return;\r\n    }\r\n\r\n    public id(): string {\r\n        return this.privId;\r\n    }\r\n\r\n    public async attach(audioNodeId: string): Promise<IAudioStreamNode> {\r\n        this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\r\n\r\n        const stream: Stream<ArrayBuffer> = await this.upload(audioNodeId);\r\n\r\n        this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\r\n        return Promise.resolve({\r\n            detach: async (): Promise<void> => {\r\n                stream.readEnded();\r\n                delete this.privStreams[audioNodeId];\r\n                this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\r\n                await this.turnOff();\r\n            },\r\n            id: (): string => audioNodeId,\r\n            read: (): Promise<IStreamChunk<ArrayBuffer>> => stream.read(),\r\n        });\r\n    }\r\n\r\n    public detach(audioNodeId: string): void {\r\n        if (audioNodeId && this.privStreams[audioNodeId]) {\r\n            this.privStreams[audioNodeId].close();\r\n            delete this.privStreams[audioNodeId];\r\n            this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\r\n        }\r\n    }\r\n\r\n    public turnOff(): Promise<void> {\r\n        for (const streamId in this.privStreams) {\r\n            if (streamId) {\r\n                const stream = this.privStreams[streamId];\r\n                if (stream && !stream.isClosed) {\r\n                    stream.close();\r\n                }\r\n            }\r\n        }\r\n\r\n        this.onEvent(new AudioSourceOffEvent(this.privId)); // no stream now\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public get events(): EventSource<AudioSourceEvent> {\r\n        return this.privEvents;\r\n    }\r\n\r\n    public get deviceInfo(): Promise<ISpeechConfigAudioDevice> {\r\n        return this.privAudioFormatPromise.then<ISpeechConfigAudioDevice>((result: AudioStreamFormatImpl): Promise<{\r\n            bitspersample: number;\r\n            channelcount: number;\r\n            connectivity: connectivity.Unknown;\r\n            manufacturer: string;\r\n            model: string;\r\n            samplerate: number;\r\n            type: type.File;\r\n        }> => ( Promise.resolve({\r\n                bitspersample: result.bitsPerSample,\r\n                channelcount: result.channels,\r\n                connectivity: connectivity.Unknown,\r\n                manufacturer: \"Speech SDK\",\r\n                model: \"File\",\r\n                samplerate: result.samplesPerSec,\r\n                type: type.File,\r\n            })\r\n        ));\r\n    }\r\n\r\n    private readHeader(): Promise<AudioStreamFormatImpl> {\r\n        // Read the wave header.\r\n        const maxHeaderSize: number = 512;\r\n        const header: Blob | Buffer = this.privSource.slice(0, maxHeaderSize);\r\n\r\n        const headerResult: Deferred<AudioStreamFormatImpl> = new Deferred<AudioStreamFormatImpl>();\r\n\r\n        const processHeader = (header: ArrayBuffer): void => {\r\n            const view: DataView = new DataView(header);\r\n\r\n            const getWord = (index: number): string => String.fromCharCode(view.getUint8(index), view.getUint8(index + 1), view.getUint8(index + 2), view.getUint8(index + 3));\r\n\r\n            // RIFF 4 bytes.\r\n            if (\"RIFF\" !== getWord(0)) {\r\n                headerResult.reject(\"Invalid WAV header in file, RIFF was not found\");\r\n                return;\r\n            }\r\n\r\n            // length, 4 bytes\r\n            // RIFF Type & fmt 8 bytes\r\n            if (\"WAVE\" !== getWord(8) || \"fmt \" !== getWord(12)) {\r\n                headerResult.reject(\"Invalid WAV header in file, WAVEfmt was not found\");\r\n                return;\r\n            }\r\n\r\n            const formatSize: number = view.getInt32(16, true);\r\n            const channelCount: number = view.getUint16(22, true);\r\n            const sampleRate: number = view.getUint32(24, true);\r\n            const bitsPerSample: number = view.getUint16(34, true);\r\n            // Confirm if header is 44 bytes long.\r\n            let pos: number = 36 + Math.max(formatSize - 16, 0);\r\n            for (; getWord(pos) !== \"data\"; pos += 2) {\r\n                if (pos > maxHeaderSize - 8) {\r\n                    headerResult.reject(\"Invalid WAV header in file, data block was not found\");\r\n                    return;\r\n                }\r\n            }\r\n            this.privHeaderEnd = pos + 8;\r\n            headerResult.resolve(AudioStreamFormat.getWaveFormatPCM(sampleRate, bitsPerSample, channelCount) as AudioStreamFormatImpl);\r\n        };\r\n\r\n        if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && header instanceof Blob) {\r\n            const reader: FileReader = new FileReader();\r\n\r\n            reader.onload = (event: Event): void => {\r\n                const header: ArrayBuffer = (event.target as FileReader).result as ArrayBuffer;\r\n                processHeader(header);\r\n            };\r\n\r\n            reader.readAsArrayBuffer(header);\r\n        } else {\r\n            const h: Buffer = header as Buffer;\r\n            processHeader(h.buffer.slice(h.byteOffset, h.byteOffset + h.byteLength));\r\n        }\r\n        return headerResult.promise;\r\n    }\r\n\r\n    private async upload(audioNodeId: string): Promise<Stream<ArrayBuffer>> {\r\n        const onerror = (error: string): void => {\r\n            const errorMsg = `Error occurred while processing '${this.privFilename}'. ${error}`;\r\n            this.onEvent(new AudioStreamNodeErrorEvent(this.privId, audioNodeId, errorMsg));\r\n            throw new Error(errorMsg);\r\n        };\r\n\r\n        try {\r\n            await this.turnOn();\r\n\r\n            const format: AudioStreamFormatImpl = await this.privAudioFormatPromise;\r\n            const stream = new ChunkedArrayBufferStream(format.avgBytesPerSec / 10, audioNodeId);\r\n\r\n            this.privStreams[audioNodeId] = stream;\r\n            const chunk: Blob | Buffer = this.privSource.slice(this.privHeaderEnd);\r\n\r\n            const processFile = (buff: ArrayBuffer): void => {\r\n                if (stream.isClosed) {\r\n                    return; // output stream was closed (somebody called TurnOff). We're done here.\r\n                }\r\n\r\n                stream.writeStreamChunk({\r\n                    buffer: buff,\r\n                    isEnd: false,\r\n                    timeReceived: Date.now(),\r\n                });\r\n                stream.close();\r\n            };\r\n\r\n            if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && chunk instanceof Blob) {\r\n                const reader: FileReader = new FileReader();\r\n                reader.onerror = (ev: ProgressEvent<FileReader>): void  =>  onerror(ev.toString());\r\n\r\n                reader.onload = (event: Event): void => {\r\n                    const fileBuffer: ArrayBuffer = (event.target as FileReader).result as ArrayBuffer;\r\n                    processFile(fileBuffer);\r\n                };\r\n\r\n                reader.readAsArrayBuffer(chunk);\r\n            } else {\r\n                const c: Buffer = chunk as Buffer;\r\n                processFile(c.buffer.slice(c.byteOffset, c.byteOffset + c.byteLength));\r\n            }\r\n\r\n            return stream;\r\n        } catch (e) {\r\n            onerror(e as string);\r\n        }\r\n    }\r\n\r\n    private onEvent(event: AudioSourceEvent): void {\r\n        this.privEvents.onEvent(event);\r\n        Events.instance.onEvent(event);\r\n    }\r\n}\r\n"]}},"error":null,"hash":"14cac6ae42acbd25c6c6e4be18d1403b","cacheData":{"env":{}}}