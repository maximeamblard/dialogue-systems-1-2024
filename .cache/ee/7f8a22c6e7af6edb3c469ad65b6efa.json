{"id":"../node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DialogServiceAdapter.js","dependencies":[{"name":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DialogServiceAdapter.js.map","includedInParent":true,"mtime":1733074701821},{"name":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/package.json","includedInParent":true,"mtime":1733076065657},{"name":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/package.json","includedInParent":true,"mtime":1733074701821},{"name":"../common.browser/Exports","loc":{"line":55,"column":24,"index":3294},"parent":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DialogServiceAdapter.js","resolved":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/Exports.js"},{"name":"../common/DialogEvents","loc":{"line":56,"column":29,"index":3353},"parent":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DialogServiceAdapter.js","resolved":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/DialogEvents.js"},{"name":"../common/Exports","loc":{"line":57,"column":24,"index":3404},"parent":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DialogServiceAdapter.js","resolved":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js"},{"name":"../sdk/Audio/AudioOutputFormat","loc":{"line":58,"column":34,"index":3460},"parent":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DialogServiceAdapter.js","resolved":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioOutputFormat.js"},{"name":"../sdk/Exports","loc":{"line":59,"column":24,"index":3519},"parent":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DialogServiceAdapter.js","resolved":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js"},{"name":"./DialogServiceTurnStateManager","loc":{"line":60,"column":46,"index":3584},"parent":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DialogServiceAdapter.js","resolved":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DialogServiceTurnStateManager.js"},{"name":"./Exports","loc":{"line":61,"column":24,"index":3644},"parent":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DialogServiceAdapter.js","resolved":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js"},{"name":"./ServiceMessages/ActivityResponsePayload","loc":{"line":62,"column":40,"index":3698},"parent":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DialogServiceAdapter.js","resolved":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/ActivityResponsePayload.js"},{"name":"./SpeechConnectionMessage.Internal","loc":{"line":63,"column":49,"index":3793},"parent":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DialogServiceAdapter.js","resolved":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechConnectionMessage.Internal.js"}],"generated":{"js":"\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DialogServiceAdapter = void 0;\nvar Exports_1 = require(\"../common.browser/Exports\");\nvar DialogEvents_1 = require(\"../common/DialogEvents\");\nvar Exports_2 = require(\"../common/Exports\");\nvar AudioOutputFormat_1 = require(\"../sdk/Audio/AudioOutputFormat\");\nvar Exports_3 = require(\"../sdk/Exports\");\nvar DialogServiceTurnStateManager_1 = require(\"./DialogServiceTurnStateManager\");\nvar Exports_4 = require(\"./Exports\");\nvar ActivityResponsePayload_1 = require(\"./ServiceMessages/ActivityResponsePayload\");\nvar SpeechConnectionMessage_Internal_1 = require(\"./SpeechConnectionMessage.Internal\");\nvar DialogServiceAdapter = /** @class */ (function (_super) {\n    __extends(DialogServiceAdapter, _super);\n    function DialogServiceAdapter(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector) {\n        var _this = _super.call(this, authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector) || this;\n        _this.privEvents = new Exports_2.EventSource();\n        _this.privDialogServiceConnector = dialogServiceConnector;\n        _this.receiveMessageOverride = function () { return _this.receiveDialogMessageOverride(); };\n        _this.privTurnStateManager = new DialogServiceTurnStateManager_1.DialogServiceTurnStateManager();\n        _this.recognizeOverride =\n            function (recoMode, successCallback, errorCallback) {\n                return _this.listenOnce(recoMode, successCallback, errorCallback);\n            };\n        _this.postConnectImplOverride = function (connection) { return _this.dialogConnectImpl(connection); };\n        _this.configConnectionOverride = function (connection) { return _this.configConnection(connection); };\n        _this.disconnectOverride = function () { return _this.privDisconnect(); };\n        _this.privDialogAudioSource = audioSource;\n        _this.agentConfigSent = false;\n        _this.privLastResult = null;\n        _this.connectionEvents.attach(function (connectionEvent) {\n            if (connectionEvent.name === \"ConnectionClosedEvent\") {\n                _this.terminateMessageLoop = true;\n            }\n        });\n        return _this;\n    }\n    DialogServiceAdapter.prototype.sendMessage = function (message) {\n        return __awaiter(this, void 0, void 0, function () {\n            var interactionGuid, requestId, agentMessage, agentMessageJson, connection;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        interactionGuid = Exports_2.createGuid();\n                        requestId = Exports_2.createNoDashGuid();\n                        agentMessage = {\n                            context: {\n                                interactionId: interactionGuid\n                            },\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                            messagePayload: JSON.parse(message),\n                            version: 0.5\n                        };\n                        agentMessageJson = JSON.stringify(agentMessage);\n                        return [4 /*yield*/, this.fetchConnection()];\n                    case 1:\n                        connection = _a.sent();\n                        return [4 /*yield*/, connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_2.MessageType.Text, \"agent\", requestId, \"application/json\", agentMessageJson))];\n                    case 2:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    DialogServiceAdapter.prototype.privDisconnect = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_3.CancellationReason.Error, Exports_3.CancellationErrorCode.NoError, \"Disconnecting\")];\n                    case 1:\n                        _a.sent();\n                        this.terminateMessageLoop = true;\n                        this.agentConfigSent = false;\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    DialogServiceAdapter.prototype.processTypeSpecificMessages = function (connectionMessage) {\n        var resultProps = new Exports_3.PropertyCollection();\n        if (connectionMessage.messageType === Exports_2.MessageType.Text) {\n            resultProps.setProperty(Exports_3.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\n        }\n        var result;\n        var processed;\n        switch (connectionMessage.path.toLowerCase()) {\n            case \"speech.phrase\":\n                var speechPhrase = Exports_4.SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\n                this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + speechPhrase.Offset + speechPhrase.Duration);\n                if (speechPhrase.RecognitionStatus !== Exports_4.RecognitionStatus.TooManyRequests && speechPhrase.RecognitionStatus !== Exports_4.RecognitionStatus.Error) {\n                    var args = this.fireEventForResult(speechPhrase, resultProps);\n                    this.privLastResult = args.result;\n                    if (!!this.privDialogServiceConnector.recognized) {\n                        try {\n                            this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, args);\n                            /* eslint-disable no-empty */\n                        }\n                        catch (error) {\n                            // Not going to let errors in the event handler\n                            // trip things up.\n                        }\n                    }\n                }\n                processed = true;\n                break;\n            case \"speech.hypothesis\":\n                var hypothesis = Exports_4.SpeechHypothesis.fromJSON(connectionMessage.textBody);\n                var offset = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;\n                result = new Exports_3.SpeechRecognitionResult(this.privRequestSession.requestId, Exports_3.ResultReason.RecognizingSpeech, hypothesis.Text, hypothesis.Duration, offset, hypothesis.Language, hypothesis.LanguageDetectionConfidence, undefined, undefined, connectionMessage.textBody, resultProps);\n                this.privRequestSession.onHypothesis(offset);\n                var ev = new Exports_3.SpeechRecognitionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);\n                if (!!this.privDialogServiceConnector.recognizing) {\n                    try {\n                        this.privDialogServiceConnector.recognizing(this.privDialogServiceConnector, ev);\n                        /* eslint-disable no-empty */\n                    }\n                    catch (error) {\n                        // Not going to let errors in the event handler\n                        // trip things up.\n                    }\n                }\n                processed = true;\n                break;\n            case \"speech.keyword\":\n                var keyword = Exports_4.SpeechKeyword.fromJSON(connectionMessage.textBody);\n                result = new Exports_3.SpeechRecognitionResult(this.privRequestSession.requestId, keyword.Status === \"Accepted\" ? Exports_3.ResultReason.RecognizedKeyword : Exports_3.ResultReason.NoMatch, keyword.Text, keyword.Duration, keyword.Offset, undefined, undefined, undefined, undefined, connectionMessage.textBody, resultProps);\n                if (keyword.Status !== \"Accepted\") {\n                    this.privLastResult = result;\n                }\n                var event_1 = new Exports_3.SpeechRecognitionEventArgs(result, result.duration, result.resultId);\n                if (!!this.privDialogServiceConnector.recognized) {\n                    try {\n                        this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, event_1);\n                        /* eslint-disable no-empty */\n                    }\n                    catch (error) {\n                        // Not going to let errors in the event handler\n                        // trip things up.\n                    }\n                }\n                processed = true;\n                break;\n            case \"audio\":\n                {\n                    var audioRequestId = connectionMessage.requestId.toUpperCase();\n                    var turn = this.privTurnStateManager.GetTurn(audioRequestId);\n                    try {\n                        // Empty binary message signals end of stream.\n                        if (!connectionMessage.binaryBody) {\n                            turn.endAudioStream();\n                        }\n                        else {\n                            turn.audioStream.write(connectionMessage.binaryBody);\n                        }\n                    }\n                    catch (error) {\n                        // Not going to let errors in the event handler\n                        // trip things up.\n                    }\n                }\n                processed = true;\n                break;\n            case \"response\":\n                {\n                    this.handleResponseMessage(connectionMessage);\n                }\n                processed = true;\n                break;\n            default:\n                break;\n        }\n        var defferal = new Exports_2.Deferred();\n        defferal.resolve(processed);\n        return defferal.promise;\n    };\n    // Cancels recognition.\n    DialogServiceAdapter.prototype.cancelRecognition = function (sessionId, requestId, cancellationReason, errorCode, error) {\n        return __awaiter(this, void 0, void 0, function () {\n            var properties, cancelEvent, result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.terminateMessageLoop = true;\n                        if (!!!this.privRequestSession.isRecognizing) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.privRequestSession.onStopRecognizing()];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        if (!!this.privDialogServiceConnector.canceled) {\n                            properties = new Exports_3.PropertyCollection();\n                            properties.setProperty(Exports_4.CancellationErrorCodePropertyName, Exports_3.CancellationErrorCode[errorCode]);\n                            cancelEvent = new Exports_3.SpeechRecognitionCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);\n                            try {\n                                this.privDialogServiceConnector.canceled(this.privDialogServiceConnector, cancelEvent);\n                                /* eslint-disable no-empty */\n                            }\n                            catch (_b) { }\n                            if (!!this.privSuccessCallback) {\n                                result = new Exports_3.SpeechRecognitionResult(undefined, // ResultId\n                                Exports_3.ResultReason.Canceled, undefined, // Text\n                                undefined, // Duration\n                                undefined, // Offset\n                                undefined, // Language\n                                undefined, // Language Detection Confidence\n                                undefined, // Speaker Id\n                                error, undefined, // Json\n                                properties);\n                                try {\n                                    this.privSuccessCallback(result);\n                                    this.privSuccessCallback = undefined;\n                                    /* eslint-disable no-empty */\n                                }\n                                catch (_c) { }\n                            }\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    DialogServiceAdapter.prototype.listenOnce = function (recoMode, successCallback, errorCallback) {\n        return __awaiter(this, void 0, void 0, function () {\n            var conPromise, preAudioPromise, node, format, deviceInfo, audioNode, error_1, sessionStartEventArgs, audioSendPromise;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.privRecognizerConfig.recognitionMode = recoMode;\n                        this.privSuccessCallback = successCallback;\n                        this.privErrorCallback = errorCallback;\n                        this.privRequestSession.startNewRecognition();\n                        this.privRequestSession.listenForServiceTelemetry(this.privDialogAudioSource.events);\n                        this.privRecognizerConfig.parameters.setProperty(Exports_3.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);\n                        conPromise = this.connectImpl();\n                        preAudioPromise = this.sendPreAudioMessages();\n                        return [4 /*yield*/, this.privDialogAudioSource.attach(this.privRequestSession.audioNodeId)];\n                    case 1:\n                        node = _a.sent();\n                        return [4 /*yield*/, this.privDialogAudioSource.format];\n                    case 2:\n                        format = _a.sent();\n                        return [4 /*yield*/, this.privDialogAudioSource.deviceInfo];\n                    case 3:\n                        deviceInfo = _a.sent();\n                        audioNode = new Exports_1.ReplayableAudioNode(node, format.avgBytesPerSec);\n                        return [4 /*yield*/, this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false)];\n                    case 4:\n                        _a.sent();\n                        this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: deviceInfo };\n                        _a.label = 5;\n                    case 5:\n                        _a.trys.push([5, 8, , 10]);\n                        return [4 /*yield*/, conPromise];\n                    case 6:\n                        _a.sent();\n                        return [4 /*yield*/, preAudioPromise];\n                    case 7:\n                        _a.sent();\n                        return [3 /*break*/, 10];\n                    case 8:\n                        error_1 = _a.sent();\n                        return [4 /*yield*/, this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_3.CancellationReason.Error, Exports_3.CancellationErrorCode.ConnectionFailure, error_1)];\n                    case 9:\n                        _a.sent();\n                        return [2 /*return*/, Promise.resolve()];\n                    case 10:\n                        sessionStartEventArgs = new Exports_3.SessionEventArgs(this.privRequestSession.sessionId);\n                        if (!!this.privRecognizer.sessionStarted) {\n                            this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);\n                        }\n                        audioSendPromise = this.sendAudio(audioNode);\n                        // /* eslint-disable no-empty */\n                        audioSendPromise.then(function () { }, function (error) { return __awaiter(_this, void 0, void 0, function () {\n                            return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0: return [4 /*yield*/, this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_3.CancellationReason.Error, Exports_3.CancellationErrorCode.RuntimeError, error)];\n                                    case 1:\n                                        _a.sent();\n                                        return [2 /*return*/];\n                                }\n                            });\n                        }); });\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    // Establishes a websocket connection to the end point.\n    DialogServiceAdapter.prototype.dialogConnectImpl = function (connection) {\n        this.privConnectionLoop = this.startMessageLoop();\n        return connection;\n    };\n    DialogServiceAdapter.prototype.receiveDialogMessageOverride = function () {\n        var _this = this;\n        // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\n        var communicationCustodian = new Exports_2.Deferred();\n        var loop = function () { return __awaiter(_this, void 0, void 0, function () {\n            var isDisposed, terminateMessageLoop, connection, message, connectionMessage, _a, turnRequestId, audioSessionReqId, speechStartDetected, speechStartEventArgs, json, speechStopDetected, speechStopEventArgs, turnEndRequestId, audioSessionReqId, sessionStopEventArgs, processed, e_1, ret, error_2;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _b.trys.push([0, 14, , 15]);\n                        isDisposed = this.isDisposed();\n                        terminateMessageLoop = (!this.isDisposed() && this.terminateMessageLoop);\n                        if (isDisposed || terminateMessageLoop) {\n                            // We're done.\n                            communicationCustodian.resolve(undefined);\n                            return [2 /*return*/];\n                        }\n                        return [4 /*yield*/, this.fetchConnection()];\n                    case 1:\n                        connection = _b.sent();\n                        return [4 /*yield*/, connection.read()];\n                    case 2:\n                        message = _b.sent();\n                        if (!message) {\n                            return [2 /*return*/, loop()];\n                        }\n                        connectionMessage = SpeechConnectionMessage_Internal_1.SpeechConnectionMessage.fromConnectionMessage(message);\n                        _a = connectionMessage.path.toLowerCase();\n                        switch (_a) {\n                            case \"turn.start\": return [3 /*break*/, 3];\n                            case \"speech.startdetected\": return [3 /*break*/, 4];\n                            case \"speech.enddetected\": return [3 /*break*/, 5];\n                            case \"turn.end\": return [3 /*break*/, 6];\n                        }\n                        return [3 /*break*/, 10];\n                    case 3:\n                        {\n                            turnRequestId = connectionMessage.requestId.toUpperCase();\n                            audioSessionReqId = this.privRequestSession.requestId.toUpperCase();\n                            // turn started by the service\n                            if (turnRequestId !== audioSessionReqId) {\n                                this.privTurnStateManager.StartTurn(turnRequestId);\n                            }\n                            else {\n                                this.privRequestSession.onServiceTurnStartResponse();\n                            }\n                        }\n                        return [3 /*break*/, 13];\n                    case 4:\n                        speechStartDetected = Exports_4.SpeechDetected.fromJSON(connectionMessage.textBody);\n                        speechStartEventArgs = new Exports_3.RecognitionEventArgs(speechStartDetected.Offset, this.privRequestSession.sessionId);\n                        if (!!this.privRecognizer.speechStartDetected) {\n                            this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);\n                        }\n                        return [3 /*break*/, 13];\n                    case 5:\n                        json = void 0;\n                        if (connectionMessage.textBody.length > 0) {\n                            json = connectionMessage.textBody;\n                        }\n                        else {\n                            // If the request was empty, the JSON returned is empty.\n                            json = \"{ Offset: 0 }\";\n                        }\n                        speechStopDetected = Exports_4.SpeechDetected.fromJSON(json);\n                        this.privRequestSession.onServiceRecognized(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset);\n                        speechStopEventArgs = new Exports_3.RecognitionEventArgs(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);\n                        if (!!this.privRecognizer.speechEndDetected) {\n                            this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);\n                        }\n                        return [3 /*break*/, 13];\n                    case 6:\n                        turnEndRequestId = connectionMessage.requestId.toUpperCase();\n                        audioSessionReqId = this.privRequestSession.requestId.toUpperCase();\n                        if (!(turnEndRequestId !== audioSessionReqId)) return [3 /*break*/, 7];\n                        this.privTurnStateManager.CompleteTurn(turnEndRequestId);\n                        return [3 /*break*/, 9];\n                    case 7:\n                        sessionStopEventArgs = new Exports_3.SessionEventArgs(this.privRequestSession.sessionId);\n                        return [4 /*yield*/, this.privRequestSession.onServiceTurnEndResponse(false)];\n                    case 8:\n                        _b.sent();\n                        if (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {\n                            if (!!this.privRecognizer.sessionStopped) {\n                                this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs);\n                            }\n                        }\n                        // report result to promise.\n                        if (!!this.privSuccessCallback && this.privLastResult) {\n                            try {\n                                this.privSuccessCallback(this.privLastResult);\n                                this.privLastResult = null;\n                            }\n                            catch (e) {\n                                if (!!this.privErrorCallback) {\n                                    this.privErrorCallback(e);\n                                }\n                            }\n                            // Only invoke the call back once.\n                            // and if it's successful don't invoke the\n                            // error after that.\n                            this.privSuccessCallback = undefined;\n                            this.privErrorCallback = undefined;\n                        }\n                        _b.label = 9;\n                    case 9: return [3 /*break*/, 13];\n                    case 10:\n                        _b.trys.push([10, 12, , 13]);\n                        return [4 /*yield*/, this.processTypeSpecificMessages(connectionMessage)];\n                    case 11:\n                        processed = _b.sent();\n                        if (!processed) {\n                            if (!!this.serviceEvents) {\n                                this.serviceEvents.onEvent(new Exports_2.ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\n                            }\n                        }\n                        return [3 /*break*/, 13];\n                    case 12:\n                        e_1 = _b.sent();\n                        return [3 /*break*/, 13];\n                    case 13:\n                        ret = loop();\n                        return [2 /*return*/, ret];\n                    case 14:\n                        error_2 = _b.sent();\n                        this.terminateMessageLoop = true;\n                        communicationCustodian.resolve();\n                        return [3 /*break*/, 15];\n                    case 15: return [2 /*return*/];\n                }\n            });\n        }); };\n        loop().catch(function (reason) {\n            Exports_2.Events.instance.onEvent(new Exports_2.BackgroundEvent(reason));\n        });\n        return communicationCustodian.promise;\n    };\n    DialogServiceAdapter.prototype.startMessageLoop = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var error_3;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.terminateMessageLoop = false;\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 5]);\n                        return [4 /*yield*/, this.receiveDialogMessageOverride()];\n                    case 2:\n                        _a.sent();\n                        return [3 /*break*/, 5];\n                    case 3:\n                        error_3 = _a.sent();\n                        return [4 /*yield*/, this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_3.CancellationReason.Error, Exports_3.CancellationErrorCode.RuntimeError, error_3)];\n                    case 4:\n                        _a.sent();\n                        return [3 /*break*/, 5];\n                    case 5: return [2 /*return*/, Promise.resolve()];\n                }\n            });\n        });\n    };\n    // Takes an established websocket connection to the endpoint and sends speech configuration information.\n    DialogServiceAdapter.prototype.configConnection = function (connection) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (this.terminateMessageLoop) {\n                            this.terminateMessageLoop = false;\n                            return [2 /*return*/, Promise.reject(\"Connection to service terminated.\")];\n                        }\n                        return [4 /*yield*/, this.sendSpeechServiceConfig(connection, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize())];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, this.sendAgentConfig(connection)];\n                    case 2:\n                        _a.sent();\n                        return [2 /*return*/, connection];\n                }\n            });\n        });\n    };\n    DialogServiceAdapter.prototype.sendPreAudioMessages = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var connection;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.fetchConnection()];\n                    case 1:\n                        connection = _a.sent();\n                        this.addKeywordContextData();\n                        return [4 /*yield*/, this.sendSpeechContext(connection, true)];\n                    case 2:\n                        _a.sent();\n                        return [4 /*yield*/, this.sendAgentContext(connection)];\n                    case 3:\n                        _a.sent();\n                        return [4 /*yield*/, this.sendWaveHeader(connection)];\n                    case 4:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    DialogServiceAdapter.prototype.sendAgentConfig = function (connection) {\n        if (this.agentConfig && !this.agentConfigSent) {\n            if (this.privRecognizerConfig\n                .parameters\n                .getProperty(Exports_3.PropertyId.Conversation_DialogType) === Exports_3.DialogServiceConfig.DialogTypes.CustomCommands) {\n                var config = this.agentConfig.get();\n                config.botInfo.commandsCulture = this.privRecognizerConfig.parameters.getProperty(Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage, \"en-us\");\n                this.agentConfig.set(config);\n            }\n            this.onEvent(new DialogEvents_1.SendingAgentContextMessageEvent(this.agentConfig));\n            var agentConfigJson = this.agentConfig.toJsonString();\n            // guard against sending this multiple times on one connection\n            this.agentConfigSent = true;\n            return connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_2.MessageType.Text, \"agent.config\", this.privRequestSession.requestId, \"application/json\", agentConfigJson));\n        }\n        return;\n    };\n    DialogServiceAdapter.prototype.sendAgentContext = function (connection) {\n        var guid = Exports_2.createGuid();\n        var speechActivityTemplate = this.privDialogServiceConnector.properties.getProperty(Exports_3.PropertyId.Conversation_Speech_Activity_Template);\n        var agentContext = {\n            channelData: \"\",\n            context: {\n                interactionId: guid\n            },\n            messagePayload: typeof speechActivityTemplate === undefined ? undefined : speechActivityTemplate,\n            version: 0.5\n        };\n        var agentContextJson = JSON.stringify(agentContext);\n        return connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_2.MessageType.Text, \"speech.agent.context\", this.privRequestSession.requestId, \"application/json\", agentContextJson));\n    };\n    DialogServiceAdapter.prototype.fireEventForResult = function (serviceResult, properties) {\n        var resultReason = Exports_4.EnumTranslation.implTranslateRecognitionResult(serviceResult.RecognitionStatus);\n        var offset = serviceResult.Offset + this.privRequestSession.currentTurnAudioOffset;\n        var result = new Exports_3.SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, serviceResult.DisplayText, serviceResult.Duration, offset, serviceResult.Language, serviceResult.LanguageDetectionConfidence, undefined, undefined, JSON.stringify(serviceResult), properties);\n        var ev = new Exports_3.SpeechRecognitionEventArgs(result, offset, this.privRequestSession.sessionId);\n        return ev;\n    };\n    DialogServiceAdapter.prototype.handleResponseMessage = function (responseMessage) {\n        // \"response\" messages can contain either \"message\" (activity) or \"MessageStatus\" data. Fire the appropriate\n        // event according to the message type that's specified.\n        var responsePayload = JSON.parse(responseMessage.textBody);\n        switch (responsePayload.messageType.toLowerCase()) {\n            case \"message\":\n                var responseRequestId = responseMessage.requestId.toUpperCase();\n                var activityPayload = ActivityResponsePayload_1.ActivityPayloadResponse.fromJSON(responseMessage.textBody);\n                var turn = this.privTurnStateManager.GetTurn(responseRequestId);\n                // update the conversation Id\n                if (activityPayload.conversationId) {\n                    var updateAgentConfig = this.agentConfig.get();\n                    updateAgentConfig.botInfo.conversationId = activityPayload.conversationId;\n                    this.agentConfig.set(updateAgentConfig);\n                }\n                var pullAudioOutputStream = turn.processActivityPayload(activityPayload, AudioOutputFormat_1.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(this.privDialogServiceConnector.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)));\n                var activity = new Exports_3.ActivityReceivedEventArgs(activityPayload.messagePayload, pullAudioOutputStream);\n                if (!!this.privDialogServiceConnector.activityReceived) {\n                    try {\n                        this.privDialogServiceConnector.activityReceived(this.privDialogServiceConnector, activity);\n                        /* eslint-disable-next-line no-empty */\n                    }\n                    catch (error) {\n                        // Not going to let errors in the event handler\n                        // trip things up.\n                    }\n                }\n                break;\n            case \"messagestatus\":\n                if (!!this.privDialogServiceConnector.turnStatusReceived) {\n                    try {\n                        this.privDialogServiceConnector.turnStatusReceived(this.privDialogServiceConnector, new Exports_3.TurnStatusReceivedEventArgs(responseMessage.textBody));\n                        /* eslint-disable-next-line no-empty */\n                    }\n                    catch (error) {\n                        // Not going to let errors in the event handler\n                        // trip things up.\n                    }\n                }\n                break;\n            default:\n                Exports_2.Events.instance.onEvent(new Exports_2.BackgroundEvent(\"Unexpected response of type \" + responsePayload.messageType + \". Ignoring.\"));\n                break;\n        }\n    };\n    DialogServiceAdapter.prototype.onEvent = function (event) {\n        this.privEvents.onEvent(event);\n        Exports_2.Events.instance.onEvent(event);\n    };\n    DialogServiceAdapter.prototype.addKeywordContextData = function () {\n        var keywordPropertyValue = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-KeywordsToDetect\");\n        if (keywordPropertyValue === undefined) {\n            return;\n        }\n        var keywordOffsetPropertyValue = this.privRecognizerConfig.parameters\n            .getProperty(\"SPEECH-KeywordsToDetect-Offsets\");\n        var keywordDurationPropertyValue = this.privRecognizerConfig.parameters\n            .getProperty(\"SPEECH-KeywordsToDetect-Durations\");\n        var keywords = keywordPropertyValue.split(\";\");\n        var keywordOffsets = keywordOffsetPropertyValue === undefined ? [] : keywordOffsetPropertyValue.split(\";\");\n        var keywordDurations = keywordDurationPropertyValue === undefined ? [] : keywordDurationPropertyValue.split(\";\");\n        var keywordDefinitionArray = [];\n        for (var i = 0; i < keywords.length; i++) {\n            var definition = {};\n            definition.text = keywords[i];\n            if (i < keywordOffsets.length) {\n                definition.offset = Number(keywordOffsets[i]);\n            }\n            if (i < keywordDurations.length) {\n                definition.duration = Number(keywordDurations[i]);\n            }\n            keywordDefinitionArray.push(definition);\n        }\n        this.speechContext.setSection(\"invocationSource\", \"VoiceActivationWithKeyword\");\n        this.speechContext.setSection(\"keywordDetection\", [{\n                clientDetectedKeywords: keywordDefinitionArray,\n                onReject: { action: \"EndOfTurn\" },\n                type: \"startTrigger\"\n            }]);\n    };\n    return DialogServiceAdapter;\n}(Exports_4.ServiceRecognizerBase));\nexports.DialogServiceAdapter = DialogServiceAdapter;\n\n\n"},"sourceMaps":{"js":{"version":3,"sources":["src/common.speech/DialogServiceAdapter.ts"],"names":[],"mappings":"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","file":"DialogServiceAdapter.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ReplayableAudioNode\r\n} from \"../common.browser/Exports\";\r\nimport { SendingAgentContextMessageEvent } from \"../common/DialogEvents\";\r\nimport {\r\n    BackgroundEvent,\r\n    ConnectionEvent,\r\n    ConnectionMessage,\r\n    createGuid,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    DialogEvent,\r\n    Events,\r\n    EventSource,\r\n    IAudioSource,\r\n    IAudioStreamNode,\r\n    IConnection,\r\n    MessageType,\r\n    ServiceEvent,\r\n} from \"../common/Exports\";\r\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat\";\r\nimport { PullAudioOutputStreamImpl } from \"../sdk/Audio/AudioOutputStream\";\r\nimport { AudioStreamFormatImpl } from \"../sdk/Audio/AudioStreamFormat\";\r\nimport {\r\n    ActivityReceivedEventArgs,\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    DialogServiceConfig,\r\n    DialogServiceConnector,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    RecognitionEventArgs,\r\n    ResultReason,\r\n    SessionEventArgs,\r\n    SpeechRecognitionCanceledEventArgs,\r\n    SpeechRecognitionEventArgs,\r\n    SpeechRecognitionResult,\r\n    TurnStatusReceivedEventArgs,\r\n} from \"../sdk/Exports\";\r\nimport { DialogServiceTurnStateManager } from \"./DialogServiceTurnStateManager\";\r\nimport {\r\n    CancellationErrorCodePropertyName,\r\n    EnumTranslation,\r\n    ISpeechConfigAudioDevice,\r\n    RecognitionStatus,\r\n    ServiceRecognizerBase,\r\n    SimpleSpeechPhrase,\r\n    SpeechDetected,\r\n    SpeechHypothesis,\r\n    SpeechKeyword,\r\n} from \"./Exports\";\r\nimport { IAuthentication } from \"./IAuthentication\";\r\nimport { IConnectionFactory } from \"./IConnectionFactory\";\r\nimport { RecognitionMode, RecognizerConfig } from \"./RecognizerConfig\";\r\nimport { ActivityPayloadResponse } from \"./ServiceMessages/ActivityResponsePayload\";\r\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\r\n\r\nexport class DialogServiceAdapter extends ServiceRecognizerBase {\r\n    private privDialogServiceConnector: DialogServiceConnector;\r\n\r\n    private privDialogAudioSource: IAudioSource;\r\n\r\n    private privConnectionLoop: Promise<void>;\r\n    private terminateMessageLoop: boolean;\r\n    private agentConfigSent: boolean;\r\n    private privLastResult: SpeechRecognitionResult;\r\n    private privEvents: EventSource<DialogEvent>;\r\n\r\n    // Turns are of two kinds:\r\n    // 1: SR turns, end when the SR result is returned and then turn end.\r\n    // 2: Service turns where an activity is sent by the service along with the audio.\r\n    private privTurnStateManager: DialogServiceTurnStateManager;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioSource: IAudioSource,\r\n        recognizerConfig: RecognizerConfig,\r\n        dialogServiceConnector: DialogServiceConnector) {\r\n\r\n        super(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector);\r\n\r\n        this.privEvents = new EventSource<DialogEvent>();\r\n        this.privDialogServiceConnector = dialogServiceConnector;\r\n        this.receiveMessageOverride = (): Promise<void> => this.receiveDialogMessageOverride();\r\n        this.privTurnStateManager = new DialogServiceTurnStateManager();\r\n        this.recognizeOverride =\r\n            (recoMode: RecognitionMode, successCallback: (e: SpeechRecognitionResult) => void, errorCallback: (e: string) => void): Promise<void> =>\r\n            this.listenOnce(recoMode, successCallback, errorCallback);\r\n        this.postConnectImplOverride = (connection: Promise<IConnection>): Promise<IConnection> => this.dialogConnectImpl(connection);\r\n        this.configConnectionOverride = (connection: IConnection): Promise<IConnection> => this.configConnection(connection);\r\n        this.disconnectOverride = (): Promise<void> => this.privDisconnect();\r\n        this.privDialogAudioSource = audioSource;\r\n\r\n        this.agentConfigSent = false;\r\n        this.privLastResult = null;\r\n        this.connectionEvents.attach((connectionEvent: ConnectionEvent): void => {\r\n            if (connectionEvent.name === \"ConnectionClosedEvent\") {\r\n                this.terminateMessageLoop = true;\r\n            }\r\n        });\r\n    }\r\n\r\n    public async sendMessage(message: string): Promise<void> {\r\n        const interactionGuid: string = createGuid();\r\n        const requestId: string = createNoDashGuid();\r\n\r\n        const agentMessage: any = {\r\n            context: {\r\n                interactionId: interactionGuid\r\n            },\r\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n            messagePayload: JSON.parse(message),\r\n            version: 0.5\r\n        };\r\n\r\n        const agentMessageJson = JSON.stringify(agentMessage);\r\n        const connection: IConnection = await this.fetchConnection();\r\n        await connection.send(new SpeechConnectionMessage(\r\n            MessageType.Text,\r\n            \"agent\",\r\n            requestId,\r\n            \"application/json\",\r\n            agentMessageJson));\r\n\r\n    }\r\n\r\n    protected async privDisconnect(): Promise<void> {\r\n        await this.cancelRecognition(this.privRequestSession.sessionId,\r\n            this.privRequestSession.requestId,\r\n            CancellationReason.Error,\r\n            CancellationErrorCode.NoError,\r\n            \"Disconnecting\");\r\n\r\n        this.terminateMessageLoop = true;\r\n        this.agentConfigSent = false;\r\n        return;\r\n    }\r\n\r\n    protected processTypeSpecificMessages(connectionMessage: SpeechConnectionMessage): Promise<boolean> {\r\n\r\n        const resultProps: PropertyCollection = new PropertyCollection();\r\n        if (connectionMessage.messageType === MessageType.Text) {\r\n            resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\r\n        }\r\n\r\n        let result: SpeechRecognitionResult;\r\n        let processed: boolean;\r\n\r\n        switch (connectionMessage.path.toLowerCase()) {\r\n            case \"speech.phrase\":\r\n                const speechPhrase: SimpleSpeechPhrase = SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\r\n\r\n                this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + speechPhrase.Offset + speechPhrase.Duration);\r\n\r\n                if (speechPhrase.RecognitionStatus !== RecognitionStatus.TooManyRequests && speechPhrase.RecognitionStatus !== RecognitionStatus.Error) {\r\n                    const args: SpeechRecognitionEventArgs = this.fireEventForResult(speechPhrase, resultProps);\r\n                    this.privLastResult = args.result;\r\n\r\n                    if (!!this.privDialogServiceConnector.recognized) {\r\n                        try {\r\n                            this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, args);\r\n                            /* eslint-disable no-empty */\r\n                        } catch (error) {\r\n                            // Not going to let errors in the event handler\r\n                            // trip things up.\r\n                        }\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n            case \"speech.hypothesis\":\r\n                const hypothesis: SpeechHypothesis = SpeechHypothesis.fromJSON(connectionMessage.textBody);\r\n                const offset: number = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;\r\n\r\n                result = new SpeechRecognitionResult(\r\n                    this.privRequestSession.requestId,\r\n                    ResultReason.RecognizingSpeech,\r\n                    hypothesis.Text,\r\n                    hypothesis.Duration,\r\n                    offset,\r\n                    hypothesis.Language,\r\n                    hypothesis.LanguageDetectionConfidence,\r\n                    undefined,\r\n                    undefined,\r\n                    connectionMessage.textBody,\r\n                    resultProps);\r\n\r\n                this.privRequestSession.onHypothesis(offset);\r\n\r\n                const ev = new SpeechRecognitionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);\r\n\r\n                if (!!this.privDialogServiceConnector.recognizing) {\r\n                    try {\r\n                        this.privDialogServiceConnector.recognizing(this.privDialogServiceConnector, ev);\r\n                        /* eslint-disable no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n            case \"speech.keyword\":\r\n                const keyword: SpeechKeyword = SpeechKeyword.fromJSON(connectionMessage.textBody);\r\n\r\n                result = new SpeechRecognitionResult(\r\n                    this.privRequestSession.requestId,\r\n                    keyword.Status === \"Accepted\" ? ResultReason.RecognizedKeyword : ResultReason.NoMatch,\r\n                    keyword.Text,\r\n                    keyword.Duration,\r\n                    keyword.Offset,\r\n                    undefined,\r\n                    undefined,\r\n                    undefined,\r\n                    undefined,\r\n                    connectionMessage.textBody,\r\n                    resultProps);\r\n\r\n                if (keyword.Status !== \"Accepted\") {\r\n                    this.privLastResult = result;\r\n                }\r\n\r\n                const event = new SpeechRecognitionEventArgs(result, result.duration, result.resultId);\r\n\r\n                if (!!this.privDialogServiceConnector.recognized) {\r\n                    try {\r\n                        this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, event);\r\n                        /* eslint-disable no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n            case \"audio\":\r\n                {\r\n                    const audioRequestId = connectionMessage.requestId.toUpperCase();\r\n                    const turn = this.privTurnStateManager.GetTurn(audioRequestId);\r\n                    try {\r\n                        // Empty binary message signals end of stream.\r\n                        if (!connectionMessage.binaryBody) {\r\n                            turn.endAudioStream();\r\n                        } else {\r\n                            turn.audioStream.write(connectionMessage.binaryBody);\r\n                        }\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n\r\n            case \"response\":\r\n                {\r\n                    this.handleResponseMessage(connectionMessage);\r\n\r\n                }\r\n                processed = true;\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n        const defferal = new Deferred<boolean>();\r\n        defferal.resolve(processed);\r\n        return defferal.promise;\r\n    }\r\n\r\n    // Cancels recognition.\r\n    protected async cancelRecognition(\r\n        sessionId: string,\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): Promise<void> {\r\n\r\n        this.terminateMessageLoop = true;\r\n\r\n        if (!!this.privRequestSession.isRecognizing) {\r\n            await this.privRequestSession.onStopRecognizing();\r\n        }\r\n\r\n        if (!!this.privDialogServiceConnector.canceled) {\r\n            const properties: PropertyCollection = new PropertyCollection();\r\n            properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\r\n\r\n            const cancelEvent: SpeechRecognitionCanceledEventArgs = new SpeechRecognitionCanceledEventArgs(\r\n                cancellationReason,\r\n                error,\r\n                errorCode,\r\n                undefined,\r\n                sessionId);\r\n\r\n            try {\r\n                this.privDialogServiceConnector.canceled(this.privDialogServiceConnector, cancelEvent);\r\n                /* eslint-disable no-empty */\r\n            } catch { }\r\n\r\n            if (!!this.privSuccessCallback) {\r\n                const result: SpeechRecognitionResult = new SpeechRecognitionResult(\r\n                    undefined, // ResultId\r\n                    ResultReason.Canceled,\r\n                    undefined, // Text\r\n                    undefined, // Duration\r\n                    undefined, // Offset\r\n                    undefined, // Language\r\n                    undefined, // Language Detection Confidence\r\n                    undefined, // Speaker Id\r\n                    error,\r\n                    undefined, // Json\r\n                    properties);\r\n                try {\r\n                    this.privSuccessCallback(result);\r\n                    this.privSuccessCallback = undefined;\r\n                    /* eslint-disable no-empty */\r\n                } catch { }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected async listenOnce(\r\n        recoMode: RecognitionMode,\r\n        successCallback: (e: SpeechRecognitionResult) => void,\r\n        errorCallback: (e: string) => void\r\n    ): Promise<void> {\r\n        this.privRecognizerConfig.recognitionMode = recoMode;\r\n\r\n        this.privSuccessCallback = successCallback;\r\n        this.privErrorCallback = errorCallback;\r\n\r\n        this.privRequestSession.startNewRecognition();\r\n        this.privRequestSession.listenForServiceTelemetry(this.privDialogAudioSource.events);\r\n\r\n        this.privRecognizerConfig.parameters.setProperty(PropertyId.Speech_SessionId, this.privRequestSession.sessionId);\r\n\r\n        // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().\r\n        const conPromise: Promise<IConnection> = this.connectImpl();\r\n\r\n        const preAudioPromise: Promise<void> = this.sendPreAudioMessages();\r\n\r\n        const node: IAudioStreamNode = await this.privDialogAudioSource.attach(this.privRequestSession.audioNodeId);\r\n        const format: AudioStreamFormatImpl = await this.privDialogAudioSource.format;\r\n        const deviceInfo: ISpeechConfigAudioDevice = await this.privDialogAudioSource.deviceInfo;\r\n\r\n        const audioNode = new ReplayableAudioNode(node, format.avgBytesPerSec);\r\n        await this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);\r\n\r\n        this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: deviceInfo };\r\n\r\n        try {\r\n            await conPromise;\r\n            await preAudioPromise;\r\n        } catch (error) {\r\n            await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.ConnectionFailure, error as string);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const sessionStartEventArgs: SessionEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\r\n\r\n        if (!!this.privRecognizer.sessionStarted) {\r\n            this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);\r\n        }\r\n\r\n        const audioSendPromise = this.sendAudio(audioNode);\r\n\r\n        // /* eslint-disable no-empty */\r\n        audioSendPromise.then((): void => { /* add? return true;*/ }, async (error: string): Promise<void> => {\r\n            await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\r\n        });\r\n    }\r\n\r\n    // Establishes a websocket connection to the end point.\r\n    private dialogConnectImpl(connection: Promise<IConnection>): Promise<IConnection> {\r\n        this.privConnectionLoop = this.startMessageLoop();\r\n        return connection;\r\n    }\r\n\r\n    private receiveDialogMessageOverride(): Promise<void> {\r\n\r\n        // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\r\n        const communicationCustodian: Deferred<void> = new Deferred<void>();\r\n\r\n        const loop = async (): Promise<void> => {\r\n            try {\r\n                const isDisposed: boolean = this.isDisposed();\r\n                const terminateMessageLoop = (!this.isDisposed() && this.terminateMessageLoop);\r\n                if (isDisposed || terminateMessageLoop) {\r\n                    // We're done.\r\n                    communicationCustodian.resolve(undefined);\r\n                    return;\r\n                }\r\n\r\n                const connection: IConnection = await this.fetchConnection();\r\n                const message: ConnectionMessage = await connection.read();\r\n\r\n                if (!message) {\r\n                    return loop();\r\n                }\r\n\r\n                const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\r\n\r\n                switch (connectionMessage.path.toLowerCase()) {\r\n                    case \"turn.start\":\r\n                        {\r\n                            const turnRequestId = connectionMessage.requestId.toUpperCase();\r\n                            const audioSessionReqId = this.privRequestSession.requestId.toUpperCase();\r\n\r\n                            // turn started by the service\r\n                            if (turnRequestId !== audioSessionReqId) {\r\n                                this.privTurnStateManager.StartTurn(turnRequestId);\r\n                            } else {\r\n                                this.privRequestSession.onServiceTurnStartResponse();\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    case \"speech.startdetected\":\r\n                        const speechStartDetected: SpeechDetected = SpeechDetected.fromJSON(connectionMessage.textBody);\r\n\r\n                        const speechStartEventArgs = new RecognitionEventArgs(speechStartDetected.Offset, this.privRequestSession.sessionId);\r\n\r\n                        if (!!this.privRecognizer.speechStartDetected) {\r\n                            this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);\r\n                        }\r\n\r\n                        break;\r\n\r\n                    case \"speech.enddetected\":\r\n\r\n                        let json: string;\r\n\r\n                        if (connectionMessage.textBody.length > 0) {\r\n                            json = connectionMessage.textBody;\r\n                        } else {\r\n                            // If the request was empty, the JSON returned is empty.\r\n                            json = \"{ Offset: 0 }\";\r\n                        }\r\n\r\n                        const speechStopDetected: SpeechDetected = SpeechDetected.fromJSON(json);\r\n\r\n                        this.privRequestSession.onServiceRecognized(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset);\r\n\r\n                        const speechStopEventArgs = new RecognitionEventArgs(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);\r\n\r\n                        if (!!this.privRecognizer.speechEndDetected) {\r\n                            this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);\r\n                        }\r\n                        break;\r\n\r\n                    case \"turn.end\":\r\n                        {\r\n                            const turnEndRequestId = connectionMessage.requestId.toUpperCase();\r\n\r\n                            const audioSessionReqId = this.privRequestSession.requestId.toUpperCase();\r\n\r\n                            // turn started by the service\r\n                            if (turnEndRequestId !== audioSessionReqId) {\r\n                                this.privTurnStateManager.CompleteTurn(turnEndRequestId);\r\n                            } else {\r\n                                // Audio session turn\r\n\r\n                                const sessionStopEventArgs: SessionEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\r\n                                await this.privRequestSession.onServiceTurnEndResponse(false);\r\n\r\n                                if (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {\r\n                                    if (!!this.privRecognizer.sessionStopped) {\r\n                                        this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs);\r\n                                    }\r\n                                }\r\n\r\n                                // report result to promise.\r\n                                if (!!this.privSuccessCallback && this.privLastResult) {\r\n                                    try {\r\n                                        this.privSuccessCallback(this.privLastResult);\r\n                                        this.privLastResult = null;\r\n                                    } catch (e) {\r\n                                        if (!!this.privErrorCallback) {\r\n                                            this.privErrorCallback(e as string);\r\n                                        }\r\n                                    }\r\n                                    // Only invoke the call back once.\r\n                                    // and if it's successful don't invoke the\r\n                                    // error after that.\r\n                                    this.privSuccessCallback = undefined;\r\n                                    this.privErrorCallback = undefined;\r\n                                }\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    default:\r\n                        try {\r\n                            const processed = await this.processTypeSpecificMessages(connectionMessage);\r\n                            if (!processed) {\r\n                                if (!!this.serviceEvents) {\r\n                                    this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\r\n                                }\r\n                            }\r\n                        } catch (e) {\r\n                            //\r\n                        }\r\n                }\r\n                const ret: Promise<void> = loop();\r\n\r\n                return ret;\r\n            } catch (error) {\r\n                this.terminateMessageLoop = true;\r\n                communicationCustodian.resolve();\r\n            }\r\n        };\r\n\r\n        loop().catch((reason: string): void => {\r\n            Events.instance.onEvent(new BackgroundEvent(reason));\r\n        });\r\n\r\n        return communicationCustodian.promise;\r\n    }\r\n\r\n    private async startMessageLoop(): Promise<void> {\r\n\r\n        this.terminateMessageLoop = false;\r\n\r\n        try {\r\n            await this.receiveDialogMessageOverride();\r\n        } catch (error) {\r\n            await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error as string);\r\n        }\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    // Takes an established websocket connection to the endpoint and sends speech configuration information.\r\n    private async configConnection(connection: IConnection): Promise<IConnection> {\r\n        if (this.terminateMessageLoop) {\r\n            this.terminateMessageLoop = false;\r\n            return Promise.reject(\"Connection to service terminated.\");\r\n        }\r\n\r\n        await this.sendSpeechServiceConfig(connection, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize());\r\n        await this.sendAgentConfig(connection);\r\n        return connection;\r\n    }\r\n\r\n    private async sendPreAudioMessages(): Promise<void> {\r\n        const connection: IConnection = await this.fetchConnection();\r\n        this.addKeywordContextData();\r\n        await this.sendSpeechContext(connection, true);\r\n        await this.sendAgentContext(connection);\r\n        await this.sendWaveHeader(connection);\r\n    }\r\n\r\n    private sendAgentConfig(connection: IConnection): Promise<void> {\r\n        if (this.agentConfig && !this.agentConfigSent) {\r\n\r\n            if (this.privRecognizerConfig\r\n                .parameters\r\n                .getProperty(PropertyId.Conversation_DialogType) === DialogServiceConfig.DialogTypes.CustomCommands) {\r\n                const config = this.agentConfig.get();\r\n                config.botInfo.commandsCulture = this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage, \"en-us\");\r\n                this.agentConfig.set(config);\r\n            }\r\n            this.onEvent(new SendingAgentContextMessageEvent(this.agentConfig));\r\n\r\n            const agentConfigJson = this.agentConfig.toJsonString();\r\n\r\n            // guard against sending this multiple times on one connection\r\n            this.agentConfigSent = true;\r\n\r\n            return connection.send(new SpeechConnectionMessage(\r\n                MessageType.Text,\r\n                \"agent.config\",\r\n                this.privRequestSession.requestId,\r\n                \"application/json\",\r\n                agentConfigJson));\r\n        }\r\n\r\n        return;\r\n    }\r\n\r\n    private sendAgentContext(connection: IConnection): Promise<void> {\r\n        const guid: string = createGuid();\r\n\r\n        const speechActivityTemplate = this.privDialogServiceConnector.properties.getProperty(PropertyId.Conversation_Speech_Activity_Template);\r\n\r\n        const agentContext: any = {\r\n            channelData: \"\",\r\n            context: {\r\n                interactionId: guid\r\n            },\r\n            messagePayload: typeof speechActivityTemplate === undefined ? undefined : speechActivityTemplate,\r\n            version: 0.5\r\n        };\r\n\r\n        const agentContextJson = JSON.stringify(agentContext);\r\n\r\n        return connection.send(new SpeechConnectionMessage(\r\n            MessageType.Text,\r\n            \"speech.agent.context\",\r\n            this.privRequestSession.requestId,\r\n            \"application/json\",\r\n            agentContextJson));\r\n    }\r\n\r\n    private fireEventForResult(serviceResult: SimpleSpeechPhrase, properties: PropertyCollection): SpeechRecognitionEventArgs {\r\n        const resultReason: ResultReason = EnumTranslation.implTranslateRecognitionResult(serviceResult.RecognitionStatus);\r\n\r\n        const offset: number = serviceResult.Offset + this.privRequestSession.currentTurnAudioOffset;\r\n\r\n        const result = new SpeechRecognitionResult(\r\n            this.privRequestSession.requestId,\r\n            resultReason,\r\n            serviceResult.DisplayText,\r\n            serviceResult.Duration,\r\n            offset,\r\n            serviceResult.Language,\r\n            serviceResult.LanguageDetectionConfidence,\r\n            undefined,\r\n            undefined,\r\n            JSON.stringify(serviceResult),\r\n            properties);\r\n\r\n        const ev = new SpeechRecognitionEventArgs(result, offset, this.privRequestSession.sessionId);\r\n        return ev;\r\n    }\r\n\r\n    private handleResponseMessage(responseMessage: SpeechConnectionMessage): void {\r\n        // \"response\" messages can contain either \"message\" (activity) or \"MessageStatus\" data. Fire the appropriate\r\n        // event according to the message type that's specified.\r\n        const responsePayload: { messageType: string } = JSON.parse(responseMessage.textBody) as { messageType: string };\r\n        switch (responsePayload.messageType.toLowerCase()) {\r\n            case \"message\":\r\n                const responseRequestId = responseMessage.requestId.toUpperCase();\r\n                const activityPayload: ActivityPayloadResponse = ActivityPayloadResponse.fromJSON(responseMessage.textBody);\r\n                const turn = this.privTurnStateManager.GetTurn(responseRequestId);\r\n\r\n                // update the conversation Id\r\n                if (activityPayload.conversationId) {\r\n                    const updateAgentConfig = this.agentConfig.get();\r\n                    updateAgentConfig.botInfo.conversationId = activityPayload.conversationId;\r\n                    this.agentConfig.set(updateAgentConfig);\r\n                }\r\n\r\n                const pullAudioOutputStream: PullAudioOutputStreamImpl = turn.processActivityPayload(\r\n                    activityPayload,\r\n                    AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(this.privDialogServiceConnector.properties.getProperty(PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)));\r\n                const activity = new ActivityReceivedEventArgs(activityPayload.messagePayload, pullAudioOutputStream);\r\n                if (!!this.privDialogServiceConnector.activityReceived) {\r\n                    try {\r\n                        this.privDialogServiceConnector.activityReceived(this.privDialogServiceConnector, activity);\r\n                        /* eslint-disable-next-line no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case \"messagestatus\":\r\n                if (!!this.privDialogServiceConnector.turnStatusReceived) {\r\n                    try {\r\n                        this.privDialogServiceConnector.turnStatusReceived(\r\n                            this.privDialogServiceConnector,\r\n                            new TurnStatusReceivedEventArgs(responseMessage.textBody));\r\n                        /* eslint-disable-next-line no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                break;\r\n\r\n            default:\r\n                Events.instance.onEvent(\r\n                    new BackgroundEvent(`Unexpected response of type ${responsePayload.messageType}. Ignoring.`));\r\n                break;\r\n        }\r\n    }\r\n\r\n    private onEvent(event: DialogEvent): void {\r\n        this.privEvents.onEvent(event);\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    private addKeywordContextData(): void {\r\n        const keywordPropertyValue: string = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-KeywordsToDetect\");\r\n        if (keywordPropertyValue === undefined) {\r\n            return;\r\n        }\r\n\r\n        const keywordOffsetPropertyValue: string = this.privRecognizerConfig.parameters\r\n            .getProperty(\"SPEECH-KeywordsToDetect-Offsets\");\r\n        const keywordDurationPropertyValue: string = this.privRecognizerConfig.parameters\r\n            .getProperty(\"SPEECH-KeywordsToDetect-Durations\");\r\n\r\n        const keywords = keywordPropertyValue.split(\";\");\r\n        const keywordOffsets = keywordOffsetPropertyValue === undefined ? [] : keywordOffsetPropertyValue.split(\";\");\r\n        const keywordDurations = keywordDurationPropertyValue === undefined ? [] : keywordDurationPropertyValue.split(\";\");\r\n\r\n        const keywordDefinitionArray = [];\r\n        for (let i = 0; i < keywords.length; i++) {\r\n            const definition: { [section: string]: any } = {};\r\n            definition.text = keywords[i];\r\n            if (i < keywordOffsets.length) {\r\n                definition.offset = Number(keywordOffsets[i]);\r\n            }\r\n            if (i < keywordDurations.length) {\r\n                definition.duration = Number(keywordDurations[i]);\r\n            }\r\n            keywordDefinitionArray.push(definition);\r\n        }\r\n\r\n        this.speechContext.setSection(\"invocationSource\", \"VoiceActivationWithKeyword\");\r\n        this.speechContext.setSection(\"keywordDetection\", [{\r\n            clientDetectedKeywords: keywordDefinitionArray,\r\n            onReject: { action: \"EndOfTurn\" },\r\n            type: \"startTrigger\"\r\n        }]);\r\n    }\r\n}\r\n"]}},"error":null,"hash":"4793ee7dcd3b7b16882e3983f203e88a","cacheData":{"env":{}}}