{"id":"../node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesisTurn.js","dependencies":[{"name":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesisTurn.js.map","includedInParent":true,"mtime":1733074701821},{"name":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/package.json","includedInParent":true,"mtime":1733076065657},{"name":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/package.json","includedInParent":true,"mtime":1733074701821},{"name":"../common/Exports","loc":{"line":42,"column":24,"index":2701},"parent":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesisTurn.js","resolved":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js"},{"name":"../sdk/Audio/AudioOutputStream","loc":{"line":43,"column":34,"index":2757},"parent":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesisTurn.js","resolved":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioOutputStream.js"},{"name":"./ServiceMessages/SynthesisAudioMetadata","loc":{"line":44,"column":39,"index":2831},"parent":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesisTurn.js","resolved":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/SynthesisAudioMetadata.js"},{"name":"./SynthesisAdapterBase","loc":{"line":45,"column":37,"index":2913},"parent":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesisTurn.js","resolved":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesisAdapterBase.js"},{"name":"./SynthesisEvents","loc":{"line":46,"column":32,"index":2972},"parent":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesisTurn.js","resolved":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesisEvents.js"}],"generated":{"js":"\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SynthesisTurn = void 0;\nvar Exports_1 = require(\"../common/Exports\");\nvar AudioOutputStream_1 = require(\"../sdk/Audio/AudioOutputStream\");\nvar SynthesisAudioMetadata_1 = require(\"./ServiceMessages/SynthesisAudioMetadata\");\nvar SynthesisAdapterBase_1 = require(\"./SynthesisAdapterBase\");\nvar SynthesisEvents_1 = require(\"./SynthesisEvents\");\nvar SynthesisTurn = /** @class */ (function () {\n    function SynthesisTurn() {\n        this.privIsDisposed = false;\n        this.privIsSynthesizing = false;\n        this.privIsSynthesisEnded = false;\n        this.privBytesReceived = 0;\n        this.privInTurn = false;\n        this.privTextOffset = 0;\n        this.privNextSearchTextIndex = 0;\n        this.privSentenceOffset = 0;\n        this.privNextSearchSentenceIndex = 0;\n        this.privRequestId = Exports_1.createNoDashGuid();\n        this.privTurnDeferral = new Exports_1.Deferred();\n        // We're not in a turn, so resolve.\n        this.privTurnDeferral.resolve();\n    }\n    Object.defineProperty(SynthesisTurn.prototype, \"requestId\", {\n        get: function () {\n            return this.privRequestId;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SynthesisTurn.prototype, \"streamId\", {\n        get: function () {\n            return this.privStreamId;\n        },\n        set: function (value) {\n            this.privStreamId = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SynthesisTurn.prototype, \"audioOutputFormat\", {\n        get: function () {\n            return this.privAudioOutputFormat;\n        },\n        set: function (format) {\n            this.privAudioOutputFormat = format;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SynthesisTurn.prototype, \"turnCompletionPromise\", {\n        get: function () {\n            return this.privTurnDeferral.promise;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SynthesisTurn.prototype, \"isSynthesisEnded\", {\n        get: function () {\n            return this.privIsSynthesisEnded;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SynthesisTurn.prototype, \"isSynthesizing\", {\n        get: function () {\n            return this.privIsSynthesizing;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SynthesisTurn.prototype, \"currentTextOffset\", {\n        get: function () {\n            return this.privTextOffset;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SynthesisTurn.prototype, \"currentSentenceOffset\", {\n        get: function () {\n            return this.privSentenceOffset;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SynthesisTurn.prototype, \"bytesReceived\", {\n        // The number of bytes received for current turn\n        get: function () {\n            return this.privBytesReceived;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SynthesisTurn.prototype, \"audioDuration\", {\n        get: function () {\n            return this.privAudioDuration;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    SynthesisTurn.prototype.getAllReceivedAudio = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!!this.privReceivedAudio) {\n                            return [2 /*return*/, Promise.resolve(this.privReceivedAudio)];\n                        }\n                        if (!this.privIsSynthesisEnded) {\n                            return [2 /*return*/, null];\n                        }\n                        return [4 /*yield*/, this.readAllAudioFromStream()];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/, Promise.resolve(this.privReceivedAudio)];\n                }\n            });\n        });\n    };\n    SynthesisTurn.prototype.getAllReceivedAudioWithHeader = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var audio;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!!this.privReceivedAudioWithHeader) {\n                            return [2 /*return*/, this.privReceivedAudioWithHeader];\n                        }\n                        if (!this.privIsSynthesisEnded) {\n                            return [2 /*return*/, null];\n                        }\n                        if (!this.audioOutputFormat.hasHeader) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.getAllReceivedAudio()];\n                    case 1:\n                        audio = _a.sent();\n                        this.privReceivedAudioWithHeader = SynthesisAdapterBase_1.SynthesisAdapterBase.addHeader(audio, this.audioOutputFormat);\n                        return [2 /*return*/, this.privReceivedAudioWithHeader];\n                    case 2: return [2 /*return*/, this.getAllReceivedAudio()];\n                }\n            });\n        });\n    };\n    SynthesisTurn.prototype.startNewSynthesis = function (requestId, rawText, isSSML, audioDestination) {\n        this.privIsSynthesisEnded = false;\n        this.privIsSynthesizing = true;\n        this.privRequestId = requestId;\n        this.privRawText = rawText;\n        this.privIsSSML = isSSML;\n        this.privAudioOutputStream = new AudioOutputStream_1.PullAudioOutputStreamImpl();\n        this.privAudioOutputStream.format = this.privAudioOutputFormat;\n        this.privReceivedAudio = null;\n        this.privReceivedAudioWithHeader = null;\n        this.privBytesReceived = 0;\n        this.privTextOffset = 0;\n        this.privNextSearchTextIndex = 0;\n        this.privSentenceOffset = 0;\n        this.privNextSearchSentenceIndex = 0;\n        this.privPartialVisemeAnimation = \"\";\n        if (audioDestination !== undefined) {\n            this.privTurnAudioDestination = audioDestination;\n            this.privTurnAudioDestination.format = this.privAudioOutputFormat;\n        }\n        this.onEvent(new SynthesisEvents_1.SynthesisTriggeredEvent(this.requestId, undefined, audioDestination === undefined ? undefined : audioDestination.id()));\n    };\n    SynthesisTurn.prototype.onPreConnectionStart = function (authFetchEventId) {\n        this.privAuthFetchEventId = authFetchEventId;\n        this.onEvent(new SynthesisEvents_1.ConnectingToSynthesisServiceEvent(this.privRequestId, this.privAuthFetchEventId));\n    };\n    SynthesisTurn.prototype.onAuthCompleted = function (isError) {\n        if (isError) {\n            this.onComplete();\n        }\n    };\n    SynthesisTurn.prototype.onConnectionEstablishCompleted = function (statusCode) {\n        if (statusCode === 200) {\n            this.onEvent(new SynthesisEvents_1.SynthesisStartedEvent(this.requestId, this.privAuthFetchEventId));\n            this.privBytesReceived = 0;\n            return;\n        }\n        else if (statusCode === 403) {\n            this.onComplete();\n        }\n    };\n    SynthesisTurn.prototype.onServiceResponseMessage = function (responseJson) {\n        var response = JSON.parse(responseJson);\n        this.streamId = response.audio.streamId;\n    };\n    SynthesisTurn.prototype.onServiceTurnEndResponse = function () {\n        this.privInTurn = false;\n        this.privTurnDeferral.resolve();\n        this.onComplete();\n    };\n    SynthesisTurn.prototype.onServiceTurnStartResponse = function () {\n        if (!!this.privTurnDeferral && !!this.privInTurn) {\n            // What? How are we starting a turn with another not done?\n            this.privTurnDeferral.reject(\"Another turn started before current completed.\");\n            // Avoid UnhandledPromiseRejection if privTurnDeferral is not being awaited\n            // eslint-disable-next-line @typescript-eslint/no-empty-function\n            this.privTurnDeferral.promise.then().catch(function () { });\n        }\n        this.privInTurn = true;\n        this.privTurnDeferral = new Exports_1.Deferred();\n    };\n    SynthesisTurn.prototype.onAudioChunkReceived = function (data) {\n        if (this.isSynthesizing) {\n            this.privAudioOutputStream.write(data);\n            this.privBytesReceived += data.byteLength;\n            if (this.privTurnAudioDestination !== undefined) {\n                this.privTurnAudioDestination.write(data);\n            }\n        }\n    };\n    SynthesisTurn.prototype.onTextBoundaryEvent = function (metadata) {\n        this.updateTextOffset(metadata.Data.text.Text, metadata.Type);\n    };\n    SynthesisTurn.prototype.onVisemeMetadataReceived = function (metadata) {\n        if (metadata.Data.AnimationChunk !== undefined) {\n            this.privPartialVisemeAnimation += metadata.Data.AnimationChunk;\n        }\n    };\n    SynthesisTurn.prototype.onSessionEnd = function (metadata) {\n        this.privAudioDuration = metadata.Data.Offset;\n    };\n    SynthesisTurn.prototype.dispose = function () {\n        if (!this.privIsDisposed) {\n            // we should have completed by now. If we did not its an unknown error.\n            this.privIsDisposed = true;\n        }\n    };\n    SynthesisTurn.prototype.onStopSynthesizing = function () {\n        this.onComplete();\n    };\n    /**\n     * Gets the viseme animation string (merged from animation chunk), and clears the internal\n     * partial animation.\n     */\n    SynthesisTurn.prototype.getAndClearVisemeAnimation = function () {\n        var animation = this.privPartialVisemeAnimation;\n        this.privPartialVisemeAnimation = \"\";\n        return animation;\n    };\n    SynthesisTurn.prototype.onEvent = function (event) {\n        Exports_1.Events.instance.onEvent(event);\n    };\n    /**\n     * Check if the text is an XML(SSML) tag\n     * @param text\n     * @private\n     */\n    SynthesisTurn.isXmlTag = function (text) {\n        return text.length >= 2 && text[0] === \"<\" && text[text.length - 1] === \">\";\n    };\n    SynthesisTurn.prototype.updateTextOffset = function (text, type) {\n        if (type === SynthesisAudioMetadata_1.MetadataType.WordBoundary) {\n            this.privTextOffset = this.privRawText.indexOf(text, this.privNextSearchTextIndex);\n            if (this.privTextOffset >= 0) {\n                this.privNextSearchTextIndex = this.privTextOffset + text.length;\n                if (this.privIsSSML) {\n                    if (this.withinXmlTag(this.privTextOffset) && !SynthesisTurn.isXmlTag(text)) {\n                        this.updateTextOffset(text, type);\n                    }\n                }\n            }\n        }\n        else {\n            this.privSentenceOffset = this.privRawText.indexOf(text, this.privNextSearchSentenceIndex);\n            if (this.privSentenceOffset >= 0) {\n                this.privNextSearchSentenceIndex = this.privSentenceOffset + text.length;\n                if (this.privIsSSML) {\n                    if (this.withinXmlTag(this.privSentenceOffset) && !SynthesisTurn.isXmlTag(text)) {\n                        this.updateTextOffset(text, type);\n                    }\n                }\n            }\n        }\n    };\n    SynthesisTurn.prototype.onComplete = function () {\n        if (this.privIsSynthesizing) {\n            this.privIsSynthesizing = false;\n            this.privIsSynthesisEnded = true;\n            this.privAudioOutputStream.close();\n            this.privInTurn = false;\n            if (this.privTurnAudioDestination !== undefined) {\n                this.privTurnAudioDestination.close();\n                this.privTurnAudioDestination = undefined;\n            }\n        }\n    };\n    SynthesisTurn.prototype.readAllAudioFromStream = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var e_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.privIsSynthesisEnded) return [3 /*break*/, 4];\n                        this.privReceivedAudio = new ArrayBuffer(this.bytesReceived);\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this.privAudioOutputStream.read(this.privReceivedAudio)];\n                    case 2:\n                        _a.sent();\n                        return [3 /*break*/, 4];\n                    case 3:\n                        e_1 = _a.sent();\n                        this.privReceivedAudio = new ArrayBuffer(0);\n                        return [3 /*break*/, 4];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Check if current idx is in XML(SSML) tag\n     * @param idx\n     * @private\n     */\n    SynthesisTurn.prototype.withinXmlTag = function (idx) {\n        return this.privRawText.indexOf(\"<\", idx + 1) > this.privRawText.indexOf(\">\", idx + 1);\n    };\n    return SynthesisTurn;\n}());\nexports.SynthesisTurn = SynthesisTurn;\n\n\n"},"sourceMaps":{"js":{"version":3,"sources":["src/common.speech/SynthesisTurn.ts"],"names":[],"mappings":"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","file":"SynthesisTurn.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    createNoDashGuid,\r\n    Deferred,\r\n    Events,\r\n    IAudioDestination\r\n} from \"../common/Exports\";\r\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat\";\r\nimport { PullAudioOutputStreamImpl } from \"../sdk/Audio/AudioOutputStream\";\r\nimport { ISynthesisMetadata, MetadataType } from \"./ServiceMessages/SynthesisAudioMetadata\";\r\nimport { SynthesisAdapterBase } from \"./SynthesisAdapterBase\";\r\nimport {\r\n    ConnectingToSynthesisServiceEvent,\r\n    SpeechSynthesisEvent,\r\n    SynthesisStartedEvent,\r\n    SynthesisTriggeredEvent,\r\n} from \"./SynthesisEvents\";\r\n\r\nexport interface ISynthesisResponseContext {\r\n    serviceTag: string;\r\n}\r\n\r\nexport interface ISynthesisResponseAudio {\r\n    type: string;\r\n    streamId: string;\r\n}\r\n\r\nexport interface ISynthesisResponse {\r\n    context: ISynthesisResponseContext;\r\n    audio: ISynthesisResponseAudio;\r\n}\r\n\r\nexport class SynthesisTurn {\r\n\r\n    public get requestId(): string {\r\n        return this.privRequestId;\r\n    }\r\n\r\n    public get streamId(): string {\r\n        return this.privStreamId;\r\n    }\r\n\r\n    public set streamId(value: string) {\r\n        this.privStreamId = value;\r\n    }\r\n\r\n    public get audioOutputFormat(): AudioOutputFormatImpl {\r\n        return this.privAudioOutputFormat;\r\n    }\r\n\r\n    public set audioOutputFormat(format: AudioOutputFormatImpl) {\r\n        this.privAudioOutputFormat = format;\r\n    }\r\n\r\n    public get turnCompletionPromise(): Promise<void> {\r\n        return this.privTurnDeferral.promise;\r\n    }\r\n\r\n    public get isSynthesisEnded(): boolean {\r\n        return this.privIsSynthesisEnded;\r\n    }\r\n\r\n    public get isSynthesizing(): boolean {\r\n        return this.privIsSynthesizing;\r\n    }\r\n\r\n    public get currentTextOffset(): number {\r\n        return this.privTextOffset;\r\n    }\r\n\r\n    public get currentSentenceOffset(): number {\r\n        return this.privSentenceOffset;\r\n    }\r\n\r\n    // The number of bytes received for current turn\r\n    public get bytesReceived(): number {\r\n        return this.privBytesReceived;\r\n    }\r\n\r\n    public get audioDuration(): number {\r\n        return this.privAudioDuration;\r\n    }\r\n\r\n    private privIsDisposed: boolean = false;\r\n    private privAuthFetchEventId: string;\r\n    private privIsSynthesizing: boolean = false;\r\n    private privIsSynthesisEnded: boolean = false;\r\n    private privBytesReceived: number = 0;\r\n    private privRequestId: string;\r\n    private privStreamId: string;\r\n    private privTurnDeferral: Deferred<void>;\r\n    private privInTurn: boolean = false;\r\n    private privAudioOutputFormat: AudioOutputFormatImpl;\r\n    private privAudioOutputStream: PullAudioOutputStreamImpl;\r\n    private privReceivedAudio: ArrayBuffer;\r\n    private privReceivedAudioWithHeader: ArrayBuffer;\r\n    private privTextOffset: number = 0;\r\n    private privNextSearchTextIndex: number = 0;\r\n    private privSentenceOffset: number = 0;\r\n    private privNextSearchSentenceIndex: number = 0;\r\n    private privPartialVisemeAnimation: string;\r\n    private privRawText: string;\r\n    private privIsSSML: boolean;\r\n    private privTurnAudioDestination: IAudioDestination;\r\n    private privAudioDuration: number;\r\n\r\n    public constructor() {\r\n        this.privRequestId = createNoDashGuid();\r\n        this.privTurnDeferral = new Deferred<void>();\r\n\r\n        // We're not in a turn, so resolve.\r\n        this.privTurnDeferral.resolve();\r\n    }\r\n\r\n    public async getAllReceivedAudio(): Promise<ArrayBuffer> {\r\n        if (!!this.privReceivedAudio) {\r\n            return Promise.resolve(this.privReceivedAudio);\r\n        }\r\n        if (!this.privIsSynthesisEnded) {\r\n            return null;\r\n        }\r\n        await this.readAllAudioFromStream();\r\n        return Promise.resolve(this.privReceivedAudio);\r\n    }\r\n\r\n    public async getAllReceivedAudioWithHeader(): Promise<ArrayBuffer> {\r\n        if (!!this.privReceivedAudioWithHeader) {\r\n            return this.privReceivedAudioWithHeader;\r\n        }\r\n        if (!this.privIsSynthesisEnded) {\r\n            return null;\r\n        }\r\n        if (this.audioOutputFormat.hasHeader) {\r\n            const audio: ArrayBuffer = await this.getAllReceivedAudio();\r\n            this.privReceivedAudioWithHeader = SynthesisAdapterBase.addHeader(audio, this.audioOutputFormat);\r\n            return this.privReceivedAudioWithHeader;\r\n        } else {\r\n            return this.getAllReceivedAudio();\r\n        }\r\n    }\r\n\r\n    public startNewSynthesis(requestId: string, rawText: string, isSSML: boolean, audioDestination?: IAudioDestination): void {\r\n        this.privIsSynthesisEnded = false;\r\n        this.privIsSynthesizing = true;\r\n        this.privRequestId = requestId;\r\n        this.privRawText = rawText;\r\n        this.privIsSSML = isSSML;\r\n        this.privAudioOutputStream = new PullAudioOutputStreamImpl();\r\n        this.privAudioOutputStream.format = this.privAudioOutputFormat;\r\n        this.privReceivedAudio = null;\r\n        this.privReceivedAudioWithHeader = null;\r\n        this.privBytesReceived = 0;\r\n        this.privTextOffset = 0;\r\n        this.privNextSearchTextIndex = 0;\r\n        this.privSentenceOffset = 0;\r\n        this.privNextSearchSentenceIndex = 0;\r\n        this.privPartialVisemeAnimation = \"\";\r\n        if (audioDestination !== undefined) {\r\n            this.privTurnAudioDestination = audioDestination;\r\n            this.privTurnAudioDestination.format = this.privAudioOutputFormat;\r\n        }\r\n        this.onEvent(new SynthesisTriggeredEvent(this.requestId, undefined, audioDestination === undefined ? undefined : audioDestination.id()));\r\n    }\r\n\r\n    public onPreConnectionStart(authFetchEventId: string): void {\r\n        this.privAuthFetchEventId = authFetchEventId;\r\n        this.onEvent(new ConnectingToSynthesisServiceEvent(this.privRequestId, this.privAuthFetchEventId));\r\n    }\r\n\r\n    public onAuthCompleted(isError: boolean): void {\r\n        if (isError) {\r\n            this.onComplete();\r\n        }\r\n    }\r\n\r\n    public onConnectionEstablishCompleted(statusCode: number): void {\r\n        if (statusCode === 200) {\r\n            this.onEvent(new SynthesisStartedEvent(this.requestId, this.privAuthFetchEventId));\r\n            this.privBytesReceived = 0;\r\n            return;\r\n        } else if (statusCode === 403) {\r\n            this.onComplete();\r\n        }\r\n    }\r\n\r\n    public onServiceResponseMessage(responseJson: string): void {\r\n        const response: ISynthesisResponse = JSON.parse(responseJson) as ISynthesisResponse;\r\n        this.streamId = response.audio.streamId;\r\n    }\r\n\r\n    public onServiceTurnEndResponse(): void {\r\n        this.privInTurn = false;\r\n        this.privTurnDeferral.resolve();\r\n        this.onComplete();\r\n    }\r\n\r\n    public onServiceTurnStartResponse(): void {\r\n        if (!!this.privTurnDeferral && !!this.privInTurn) {\r\n            // What? How are we starting a turn with another not done?\r\n            this.privTurnDeferral.reject(\"Another turn started before current completed.\");\r\n            // Avoid UnhandledPromiseRejection if privTurnDeferral is not being awaited\r\n            // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n            this.privTurnDeferral.promise.then().catch((): void => { });\r\n        }\r\n        this.privInTurn = true;\r\n        this.privTurnDeferral = new Deferred<void>();\r\n    }\r\n\r\n    public onAudioChunkReceived(data: ArrayBuffer): void {\r\n        if (this.isSynthesizing) {\r\n            this.privAudioOutputStream.write(data);\r\n            this.privBytesReceived += data.byteLength;\r\n            if (this.privTurnAudioDestination !== undefined) {\r\n                this.privTurnAudioDestination.write(data);\r\n            }\r\n        }\r\n    }\r\n\r\n    public onTextBoundaryEvent(metadata: ISynthesisMetadata): void {\r\n        this.updateTextOffset(metadata.Data.text.Text, metadata.Type);\r\n    }\r\n\r\n    public onVisemeMetadataReceived(metadata: ISynthesisMetadata): void {\r\n        if (metadata.Data.AnimationChunk !== undefined) {\r\n            this.privPartialVisemeAnimation += metadata.Data.AnimationChunk;\r\n        }\r\n    }\r\n\r\n    public onSessionEnd(metadata: ISynthesisMetadata): void {\r\n        this.privAudioDuration = metadata.Data.Offset;\r\n    }\r\n\r\n    public dispose(): void {\r\n        if (!this.privIsDisposed) {\r\n            // we should have completed by now. If we did not its an unknown error.\r\n            this.privIsDisposed = true;\r\n        }\r\n    }\r\n\r\n    public onStopSynthesizing(): void {\r\n        this.onComplete();\r\n    }\r\n\r\n    /**\r\n     * Gets the viseme animation string (merged from animation chunk), and clears the internal\r\n     * partial animation.\r\n     */\r\n    public getAndClearVisemeAnimation(): string {\r\n        const animation: string = this.privPartialVisemeAnimation;\r\n        this.privPartialVisemeAnimation = \"\";\r\n        return animation;\r\n    }\r\n\r\n    protected onEvent(event: SpeechSynthesisEvent): void {\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    /**\r\n     * Check if the text is an XML(SSML) tag\r\n     * @param text\r\n     * @private\r\n     */\r\n    private static isXmlTag(text: string): boolean {\r\n        return text.length >= 2 && text[0] === \"<\" && text[text.length - 1] === \">\";\r\n    }\r\n\r\n    private updateTextOffset(text: string, type: MetadataType): void {\r\n        if (type === MetadataType.WordBoundary) {\r\n            this.privTextOffset = this.privRawText.indexOf(text, this.privNextSearchTextIndex);\r\n            if (this.privTextOffset >= 0) {\r\n                this.privNextSearchTextIndex = this.privTextOffset + text.length;\r\n                if (this.privIsSSML) {\r\n                    if (this.withinXmlTag(this.privTextOffset) && !SynthesisTurn.isXmlTag(text)) {\r\n                        this.updateTextOffset(text, type);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            this.privSentenceOffset = this.privRawText.indexOf(text, this.privNextSearchSentenceIndex);\r\n            if (this.privSentenceOffset >= 0) {\r\n                this.privNextSearchSentenceIndex = this.privSentenceOffset + text.length;\r\n                if (this.privIsSSML) {\r\n                    if (this.withinXmlTag(this.privSentenceOffset) && !SynthesisTurn.isXmlTag(text)) {\r\n                        this.updateTextOffset(text, type);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private onComplete(): void {\r\n        if (this.privIsSynthesizing) {\r\n            this.privIsSynthesizing = false;\r\n            this.privIsSynthesisEnded = true;\r\n            this.privAudioOutputStream.close();\r\n            this.privInTurn = false;\r\n            if (this.privTurnAudioDestination !== undefined) {\r\n                this.privTurnAudioDestination.close();\r\n                this.privTurnAudioDestination = undefined;\r\n            }\r\n        }\r\n    }\r\n\r\n    private async readAllAudioFromStream(): Promise<void> {\r\n        if (this.privIsSynthesisEnded) {\r\n            this.privReceivedAudio = new ArrayBuffer(this.bytesReceived);\r\n            try {\r\n                await this.privAudioOutputStream.read(this.privReceivedAudio);\r\n            } catch (e) {\r\n                this.privReceivedAudio = new ArrayBuffer(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if current idx is in XML(SSML) tag\r\n     * @param idx\r\n     * @private\r\n     */\r\n    private withinXmlTag(idx: number): boolean {\r\n        return this.privRawText.indexOf(\"<\", idx + 1) > this.privRawText.indexOf(\">\", idx + 1);\r\n    }\r\n}\r\n"]}},"error":null,"hash":"e4f9753ab3b8eafa463c6a87e5f2fddb","cacheData":{"env":{}}}