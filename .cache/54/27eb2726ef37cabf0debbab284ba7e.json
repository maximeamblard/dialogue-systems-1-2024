{"id":"../node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/SpeakerAudioDestination.js","dependencies":[{"name":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/SpeakerAudioDestination.js.map","includedInParent":true,"mtime":1733074701821},{"name":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/package.json","includedInParent":true,"mtime":1733076065657},{"name":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/package.json","includedInParent":true,"mtime":1733074701821},{"name":"../../common.speech/Exports","loc":{"line":43,"column":24,"index":2719},"parent":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/SpeakerAudioDestination.js","resolved":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js"},{"name":"../../common/Exports","loc":{"line":44,"column":24,"index":2775},"parent":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/SpeakerAudioDestination.js","resolved":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js"},{"name":"./AudioOutputStream","loc":{"line":45,"column":34,"index":2834},"parent":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/SpeakerAudioDestination.js","resolved":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioOutputStream.js"},{"name":"./AudioStreamFormat","loc":{"line":46,"column":34,"index":2892},"parent":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/SpeakerAudioDestination.js","resolved":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioStreamFormat.js"}],"generated":{"js":"\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SpeakerAudioDestination = void 0;\nvar Exports_1 = require(\"../../common.speech/Exports\");\nvar Exports_2 = require(\"../../common/Exports\");\nvar AudioOutputStream_1 = require(\"./AudioOutputStream\");\nvar AudioStreamFormat_1 = require(\"./AudioStreamFormat\");\nvar MediaDurationPlaceholderSeconds = 60 * 30;\nvar AudioFormatToMimeType = (_a = {},\n    _a[AudioStreamFormat_1.AudioFormatTag.PCM] = \"audio/wav\",\n    _a[AudioStreamFormat_1.AudioFormatTag.MuLaw] = \"audio/x-wav\",\n    _a[AudioStreamFormat_1.AudioFormatTag.MP3] = \"audio/mpeg\",\n    _a[AudioStreamFormat_1.AudioFormatTag.OGG_OPUS] = \"audio/ogg\",\n    _a[AudioStreamFormat_1.AudioFormatTag.WEBM_OPUS] = \"audio/webm; codecs=opus\",\n    _a[AudioStreamFormat_1.AudioFormatTag.ALaw] = \"audio/x-wav\",\n    _a[AudioStreamFormat_1.AudioFormatTag.FLAC] = \"audio/flac\",\n    _a);\n/**\n * Represents the speaker playback audio destination, which only works in browser.\n * Note: the SDK will try to use <a href=\"https://www.w3.org/TR/media-source/\">Media Source Extensions</a> to play audio.\n * Mp3 format has better supports on Microsoft Edge, Chrome and Safari (desktop), so, it's better to specify mp3 format for playback.\n * @class SpeakerAudioDestination\n * Updated in version 1.17.0\n */\nvar SpeakerAudioDestination = /** @class */ (function () {\n    function SpeakerAudioDestination(audioDestinationId) {\n        this.privPlaybackStarted = false;\n        this.privAppendingToBuffer = false;\n        this.privMediaSourceOpened = false;\n        this.privBytesReceived = 0;\n        this.privId = audioDestinationId ? audioDestinationId : Exports_2.createNoDashGuid();\n        this.privIsPaused = false;\n        this.privIsClosed = false;\n    }\n    SpeakerAudioDestination.prototype.id = function () {\n        return this.privId;\n    };\n    SpeakerAudioDestination.prototype.write = function (buffer, cb, err) {\n        if (this.privAudioBuffer !== undefined) {\n            this.privAudioBuffer.push(buffer);\n            this.updateSourceBuffer().then(function () {\n                if (!!cb) {\n                    cb();\n                }\n            }, function (error) {\n                if (!!err) {\n                    err(error);\n                }\n            });\n        }\n        else if (this.privAudioOutputStream !== undefined) {\n            this.privAudioOutputStream.write(buffer);\n            this.privBytesReceived += buffer.byteLength;\n        }\n    };\n    SpeakerAudioDestination.prototype.close = function (cb, err) {\n        var _this = this;\n        this.privIsClosed = true;\n        if (this.privSourceBuffer !== undefined) {\n            this.handleSourceBufferUpdateEnd().then(function () {\n                if (!!cb) {\n                    cb();\n                }\n            }, function (error) {\n                if (!!err) {\n                    err(error);\n                }\n            });\n        }\n        else if (this.privAudioOutputStream !== undefined && typeof window !== \"undefined\") {\n            if ((this.privFormat.formatTag === AudioStreamFormat_1.AudioFormatTag.PCM || this.privFormat.formatTag === AudioStreamFormat_1.AudioFormatTag.MuLaw\n                || this.privFormat.formatTag === AudioStreamFormat_1.AudioFormatTag.ALaw) && this.privFormat.hasHeader === false) {\n                // eslint-disable-next-line no-console\n                console.warn(\"Play back is not supported for raw PCM, mulaw or alaw format without header.\");\n                if (!!this.onAudioEnd) {\n                    this.onAudioEnd(this);\n                }\n            }\n            else {\n                var receivedAudio_1 = new ArrayBuffer(this.privBytesReceived);\n                this.privAudioOutputStream.read(receivedAudio_1).then(function () {\n                    receivedAudio_1 = Exports_1.SynthesisAdapterBase.addHeader(receivedAudio_1, _this.privFormat);\n                    var audioBlob = new Blob([receivedAudio_1], { type: AudioFormatToMimeType[_this.privFormat.formatTag] });\n                    _this.privAudio.src = window.URL.createObjectURL(audioBlob);\n                    _this.notifyPlayback().then(function () {\n                        if (!!cb) {\n                            cb();\n                        }\n                    }, function (error) {\n                        if (!!err) {\n                            err(error);\n                        }\n                    });\n                }, function (error) {\n                    if (!!err) {\n                        err(error);\n                    }\n                });\n            }\n        }\n        else {\n            // unsupported format, call onAudioEnd directly.\n            if (!!this.onAudioEnd) {\n                this.onAudioEnd(this);\n            }\n        }\n    };\n    Object.defineProperty(SpeakerAudioDestination.prototype, \"format\", {\n        set: function (format) {\n            var _this = this;\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            if (typeof (AudioContext) !== \"undefined\" || (typeof (window) !== \"undefined\" && typeof (window.webkitAudioContext) !== \"undefined\")) {\n                this.privFormat = format;\n                var mimeType_1 = AudioFormatToMimeType[this.privFormat.formatTag];\n                if (mimeType_1 === undefined) {\n                    // eslint-disable-next-line no-console\n                    console.warn(\"Unknown mimeType for format \" + AudioStreamFormat_1.AudioFormatTag[this.privFormat.formatTag] + \"; playback is not supported.\");\n                }\n                else if (typeof (MediaSource) !== \"undefined\" && MediaSource.isTypeSupported(mimeType_1)) {\n                    this.privAudio = new Audio();\n                    this.privAudioBuffer = [];\n                    this.privMediaSource = new MediaSource();\n                    this.privAudio.src = URL.createObjectURL(this.privMediaSource);\n                    this.privAudio.load();\n                    this.privMediaSource.onsourceopen = function () {\n                        _this.privMediaSourceOpened = true;\n                        _this.privMediaSource.duration = MediaDurationPlaceholderSeconds;\n                        _this.privSourceBuffer = _this.privMediaSource.addSourceBuffer(mimeType_1);\n                        _this.privSourceBuffer.onupdate = function () {\n                            _this.updateSourceBuffer().catch(function (reason) {\n                                Exports_2.Events.instance.onEvent(new Exports_2.BackgroundEvent(reason));\n                            });\n                        };\n                        _this.privSourceBuffer.onupdateend = function () {\n                            _this.handleSourceBufferUpdateEnd().catch(function (reason) {\n                                Exports_2.Events.instance.onEvent(new Exports_2.BackgroundEvent(reason));\n                            });\n                        };\n                        _this.privSourceBuffer.onupdatestart = function () {\n                            _this.privAppendingToBuffer = false;\n                        };\n                    };\n                    this.updateSourceBuffer().catch(function (reason) {\n                        Exports_2.Events.instance.onEvent(new Exports_2.BackgroundEvent(reason));\n                    });\n                }\n                else {\n                    // eslint-disable-next-line no-console\n                    console.warn(\"Format \" + AudioStreamFormat_1.AudioFormatTag[this.privFormat.formatTag] + \" could not be played by MSE, streaming playback is not enabled.\");\n                    this.privAudioOutputStream = new AudioOutputStream_1.PullAudioOutputStreamImpl();\n                    this.privAudioOutputStream.format = this.privFormat;\n                    this.privAudio = new Audio();\n                }\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SpeakerAudioDestination.prototype, \"volume\", {\n        get: function () {\n            var _a, _b;\n            return (_b = (_a = this.privAudio) === null || _a === void 0 ? void 0 : _a.volume) !== null && _b !== void 0 ? _b : -1;\n        },\n        set: function (volume) {\n            if (!!this.privAudio) {\n                this.privAudio.volume = volume;\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    SpeakerAudioDestination.prototype.mute = function () {\n        if (!!this.privAudio) {\n            this.privAudio.muted = true;\n        }\n    };\n    SpeakerAudioDestination.prototype.unmute = function () {\n        if (!!this.privAudio) {\n            this.privAudio.muted = false;\n        }\n    };\n    Object.defineProperty(SpeakerAudioDestination.prototype, \"isClosed\", {\n        get: function () {\n            return this.privIsClosed;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SpeakerAudioDestination.prototype, \"currentTime\", {\n        get: function () {\n            if (this.privAudio !== undefined) {\n                return this.privAudio.currentTime;\n            }\n            return -1;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    SpeakerAudioDestination.prototype.pause = function () {\n        if (!this.privIsPaused && this.privAudio !== undefined) {\n            this.privAudio.pause();\n            this.privIsPaused = true;\n        }\n    };\n    SpeakerAudioDestination.prototype.resume = function (cb, err) {\n        if (this.privIsPaused && this.privAudio !== undefined) {\n            this.privAudio.play().then(function () {\n                if (!!cb) {\n                    cb();\n                }\n            }, function (error) {\n                if (!!err) {\n                    err(error);\n                }\n            });\n            this.privIsPaused = false;\n        }\n    };\n    Object.defineProperty(SpeakerAudioDestination.prototype, \"internalAudio\", {\n        get: function () {\n            return this.privAudio;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    SpeakerAudioDestination.prototype.updateSourceBuffer = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var binary;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(this.privAudioBuffer !== undefined && (this.privAudioBuffer.length > 0) && this.sourceBufferAvailable())) return [3 /*break*/, 2];\n                        this.privAppendingToBuffer = true;\n                        binary = this.privAudioBuffer.shift();\n                        try {\n                            this.privSourceBuffer.appendBuffer(binary);\n                        }\n                        catch (error) {\n                            this.privAudioBuffer.unshift(binary);\n                            // eslint-disable-next-line no-console\n                            console.log(\"buffer filled, pausing addition of binaries until space is made\");\n                            return [2 /*return*/];\n                        }\n                        return [4 /*yield*/, this.notifyPlayback()];\n                    case 1:\n                        _a.sent();\n                        return [3 /*break*/, 4];\n                    case 2:\n                        if (!this.canEndStream()) return [3 /*break*/, 4];\n                        return [4 /*yield*/, this.handleSourceBufferUpdateEnd()];\n                    case 3:\n                        _a.sent();\n                        _a.label = 4;\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    SpeakerAudioDestination.prototype.handleSourceBufferUpdateEnd = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(this.canEndStream() && this.sourceBufferAvailable())) return [3 /*break*/, 2];\n                        this.privMediaSource.endOfStream();\n                        return [4 /*yield*/, this.notifyPlayback()];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    SpeakerAudioDestination.prototype.notifyPlayback = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(!this.privPlaybackStarted && this.privAudio !== undefined)) return [3 /*break*/, 2];\n                        this.privPlaybackStarted = true;\n                        if (!!this.onAudioStart) {\n                            this.onAudioStart(this);\n                        }\n                        this.privAudio.onended = function () {\n                            if (!!_this.onAudioEnd) {\n                                _this.onAudioEnd(_this);\n                            }\n                        };\n                        if (!!this.privIsPaused) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.privAudio.play()];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    SpeakerAudioDestination.prototype.canEndStream = function () {\n        return (this.isClosed && this.privSourceBuffer !== undefined && (this.privAudioBuffer.length === 0)\n            && this.privMediaSourceOpened && !this.privAppendingToBuffer && this.privMediaSource.readyState === \"open\");\n    };\n    SpeakerAudioDestination.prototype.sourceBufferAvailable = function () {\n        return (this.privSourceBuffer !== undefined && !this.privSourceBuffer.updating);\n    };\n    return SpeakerAudioDestination;\n}());\nexports.SpeakerAudioDestination = SpeakerAudioDestination;\n\n\n"},"sourceMaps":{"js":{"version":3,"sources":["src/sdk/Audio/SpeakerAudioDestination.ts"],"names":[],"mappings":"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","file":"SpeakerAudioDestination.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { SynthesisAdapterBase } from \"../../common.speech/Exports\";\r\nimport {\r\n    BackgroundEvent,\r\n    createNoDashGuid,\r\n    Events,\r\n    IAudioDestination,\r\n    INumberDictionary\r\n} from \"../../common/Exports\";\r\nimport { AudioStreamFormat, IPlayer } from \"../Exports\";\r\nimport { AudioOutputFormatImpl } from \"./AudioOutputFormat\";\r\nimport { PullAudioOutputStreamImpl } from \"./AudioOutputStream\";\r\nimport { AudioFormatTag } from \"./AudioStreamFormat\";\r\n\r\nconst MediaDurationPlaceholderSeconds = 60 * 30;\r\n\r\nconst AudioFormatToMimeType: INumberDictionary<string> = {\r\n    [AudioFormatTag.PCM]: \"audio/wav\",\r\n    [AudioFormatTag.MuLaw]: \"audio/x-wav\",\r\n    [AudioFormatTag.MP3]: \"audio/mpeg\",\r\n    [AudioFormatTag.OGG_OPUS]: \"audio/ogg\",\r\n    [AudioFormatTag.WEBM_OPUS]: \"audio/webm; codecs=opus\",\r\n    [AudioFormatTag.ALaw]: \"audio/x-wav\",\r\n    [AudioFormatTag.FLAC]: \"audio/flac\",\r\n};\r\n\r\n/**\r\n * Represents the speaker playback audio destination, which only works in browser.\r\n * Note: the SDK will try to use <a href=\"https://www.w3.org/TR/media-source/\">Media Source Extensions</a> to play audio.\r\n * Mp3 format has better supports on Microsoft Edge, Chrome and Safari (desktop), so, it's better to specify mp3 format for playback.\r\n * @class SpeakerAudioDestination\r\n * Updated in version 1.17.0\r\n */\r\nexport class SpeakerAudioDestination implements IAudioDestination, IPlayer {\r\n    private readonly privId: string;\r\n    private privFormat: AudioOutputFormatImpl;\r\n    private privAudio: HTMLAudioElement;\r\n    private privMediaSource: MediaSource;\r\n    private privSourceBuffer: SourceBuffer;\r\n    private privPlaybackStarted: boolean = false;\r\n    private privAudioBuffer: ArrayBuffer[];\r\n    private privAppendingToBuffer: boolean = false;\r\n    private privMediaSourceOpened: boolean = false;\r\n    private privIsClosed: boolean;\r\n    private privIsPaused: boolean;\r\n    private privAudioOutputStream: PullAudioOutputStreamImpl;\r\n    private privBytesReceived: number = 0;\r\n\r\n    public constructor(audioDestinationId?: string) {\r\n        this.privId = audioDestinationId ? audioDestinationId : createNoDashGuid();\r\n        this.privIsPaused = false;\r\n        this.privIsClosed = false;\r\n    }\r\n\r\n    public id(): string {\r\n        return this.privId;\r\n    }\r\n\r\n    public write(buffer: ArrayBuffer, cb?: () => void, err?: (error: string) => void): void {\r\n        if (this.privAudioBuffer !== undefined) {\r\n            this.privAudioBuffer.push(buffer);\r\n            this.updateSourceBuffer().then((): void => {\r\n                if (!!cb) {\r\n                    cb();\r\n                }\r\n            }, (error: string): void => {\r\n                if (!!err) {\r\n                    err(error);\r\n                }\r\n            });\r\n        } else if (this.privAudioOutputStream !== undefined) {\r\n            this.privAudioOutputStream.write(buffer);\r\n            this.privBytesReceived += buffer.byteLength;\r\n        }\r\n    }\r\n\r\n    public close(cb?: () => void, err?: (error: string) => void): void {\r\n        this.privIsClosed = true;\r\n        if (this.privSourceBuffer !== undefined) {\r\n            this.handleSourceBufferUpdateEnd().then((): void => {\r\n                if (!!cb) {\r\n                    cb();\r\n                }\r\n            }, (error: string): void => {\r\n                if (!!err) {\r\n                    err(error);\r\n                }\r\n            });\r\n        } else if (this.privAudioOutputStream !== undefined && typeof window !== \"undefined\") {\r\n            if ((this.privFormat.formatTag === AudioFormatTag.PCM || this.privFormat.formatTag === AudioFormatTag.MuLaw\r\n                || this.privFormat.formatTag === AudioFormatTag.ALaw) && this.privFormat.hasHeader === false) {\r\n                // eslint-disable-next-line no-console\r\n                console.warn(\"Play back is not supported for raw PCM, mulaw or alaw format without header.\");\r\n                if (!!this.onAudioEnd) {\r\n                    this.onAudioEnd(this);\r\n                }\r\n            } else {\r\n                let receivedAudio = new ArrayBuffer(this.privBytesReceived);\r\n                this.privAudioOutputStream.read(receivedAudio).then((): void => {\r\n                    receivedAudio = SynthesisAdapterBase.addHeader(receivedAudio, this.privFormat);\r\n                    const audioBlob = new Blob([receivedAudio], { type: AudioFormatToMimeType[this.privFormat.formatTag] });\r\n                    this.privAudio.src = window.URL.createObjectURL(audioBlob);\r\n                    this.notifyPlayback().then((): void => {\r\n                        if (!!cb) {\r\n                            cb();\r\n                        }\r\n                    }, (error: string): void => {\r\n                        if (!!err) {\r\n                            err(error);\r\n                        }\r\n                    });\r\n                }, (error: string): void => {\r\n                    if (!!err) {\r\n                        err(error);\r\n                    }\r\n                });\r\n            }\r\n        } else {\r\n            // unsupported format, call onAudioEnd directly.\r\n            if (!!this.onAudioEnd) {\r\n                this.onAudioEnd(this);\r\n            }\r\n        }\r\n    }\r\n\r\n    public set format(format: AudioStreamFormat) {\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\r\n        if (typeof (AudioContext) !== \"undefined\" || (typeof (window) !== \"undefined\" && typeof ((window as any).webkitAudioContext) !== \"undefined\")) {\r\n            this.privFormat = format as AudioOutputFormatImpl;\r\n            const mimeType: string = AudioFormatToMimeType[this.privFormat.formatTag];\r\n            if (mimeType === undefined) {\r\n                // eslint-disable-next-line no-console\r\n                console.warn(\r\n                    `Unknown mimeType for format ${AudioFormatTag[this.privFormat.formatTag]}; playback is not supported.`);\r\n\r\n            } else if (typeof (MediaSource) !== \"undefined\" && MediaSource.isTypeSupported(mimeType)) {\r\n                this.privAudio = new Audio();\r\n                this.privAudioBuffer = [];\r\n                this.privMediaSource = new MediaSource();\r\n                this.privAudio.src = URL.createObjectURL(this.privMediaSource);\r\n                this.privAudio.load();\r\n                this.privMediaSource.onsourceopen = (): void => {\r\n                    this.privMediaSourceOpened = true;\r\n                    this.privMediaSource.duration = MediaDurationPlaceholderSeconds;\r\n                    this.privSourceBuffer = this.privMediaSource.addSourceBuffer(mimeType);\r\n                    this.privSourceBuffer.onupdate = (): void => {\r\n                        this.updateSourceBuffer().catch((reason: string): void => {\r\n                            Events.instance.onEvent(new BackgroundEvent(reason));\r\n                        });\r\n                    };\r\n                    this.privSourceBuffer.onupdateend = (): void => {\r\n                        this.handleSourceBufferUpdateEnd().catch((reason: string): void => {\r\n                            Events.instance.onEvent(new BackgroundEvent(reason));\r\n                        });\r\n                    };\r\n                    this.privSourceBuffer.onupdatestart = (): void => {\r\n                        this.privAppendingToBuffer = false;\r\n                    };\r\n                };\r\n                this.updateSourceBuffer().catch((reason: string): void => {\r\n                    Events.instance.onEvent(new BackgroundEvent(reason));\r\n                });\r\n\r\n            } else {\r\n                // eslint-disable-next-line no-console\r\n                console.warn(\r\n                    `Format ${AudioFormatTag[this.privFormat.formatTag]} could not be played by MSE, streaming playback is not enabled.`);\r\n                this.privAudioOutputStream = new PullAudioOutputStreamImpl();\r\n                this.privAudioOutputStream.format = this.privFormat;\r\n                this.privAudio = new Audio();\r\n            }\r\n        }\r\n    }\r\n\r\n    public get volume(): number {\r\n        return this.privAudio?.volume ?? -1;\r\n    }\r\n\r\n    public set volume(volume: number) {\r\n        if (!!this.privAudio) {\r\n            this.privAudio.volume = volume;\r\n        }\r\n    }\r\n\r\n    public mute(): void {\r\n        if (!!this.privAudio) {\r\n            this.privAudio.muted = true;\r\n        }\r\n    }\r\n\r\n    public unmute(): void {\r\n        if (!!this.privAudio) {\r\n            this.privAudio.muted = false;\r\n        }\r\n    }\r\n\r\n    public get isClosed(): boolean {\r\n        return this.privIsClosed;\r\n    }\r\n\r\n    public get currentTime(): number {\r\n        if (this.privAudio !== undefined) {\r\n            return this.privAudio.currentTime;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public pause(): void {\r\n        if (!this.privIsPaused && this.privAudio !== undefined) {\r\n            this.privAudio.pause();\r\n            this.privIsPaused = true;\r\n        }\r\n    }\r\n\r\n    public resume(cb?: () => void, err?: (error: string) => void): void {\r\n        if (this.privIsPaused && this.privAudio !== undefined) {\r\n            this.privAudio.play().then((): void => {\r\n                if (!!cb) {\r\n                    cb();\r\n                }\r\n            }, (error: string): void => {\r\n                if (!!err) {\r\n                    err(error);\r\n                }\r\n            });\r\n            this.privIsPaused = false;\r\n        }\r\n    }\r\n\r\n    public onAudioStart: (sender: IPlayer) => void;\r\n\r\n    public onAudioEnd: (sender: IPlayer) => void;\r\n\r\n    public get internalAudio(): HTMLAudioElement {\r\n        return this.privAudio;\r\n    }\r\n\r\n    private async updateSourceBuffer(): Promise<void> {\r\n        if (this.privAudioBuffer !== undefined && (this.privAudioBuffer.length > 0) && this.sourceBufferAvailable()) {\r\n            this.privAppendingToBuffer = true;\r\n            const binary = this.privAudioBuffer.shift();\r\n            try {\r\n                this.privSourceBuffer.appendBuffer(binary);\r\n            } catch (error) {\r\n                this.privAudioBuffer.unshift(binary);\r\n                // eslint-disable-next-line no-console\r\n                console.log(\r\n                    \"buffer filled, pausing addition of binaries until space is made\");\r\n                return;\r\n            }\r\n            await this.notifyPlayback();\r\n        } else if (this.canEndStream()) {\r\n            await this.handleSourceBufferUpdateEnd();\r\n        }\r\n    }\r\n\r\n    private async handleSourceBufferUpdateEnd(): Promise<void> {\r\n        if (this.canEndStream() && this.sourceBufferAvailable()) {\r\n            this.privMediaSource.endOfStream();\r\n            await this.notifyPlayback();\r\n        }\r\n    }\r\n\r\n    private async notifyPlayback(): Promise<void> {\r\n        if (!this.privPlaybackStarted && this.privAudio !== undefined) {\r\n            this.privPlaybackStarted = true;\r\n            if (!!this.onAudioStart) {\r\n                this.onAudioStart(this);\r\n            }\r\n            this.privAudio.onended = (): void => {\r\n                if (!!this.onAudioEnd) {\r\n                    this.onAudioEnd(this);\r\n                }\r\n            };\r\n            if (!this.privIsPaused) {\r\n                await this.privAudio.play();\r\n            }\r\n        }\r\n    }\r\n\r\n    private canEndStream(): boolean {\r\n        return (this.isClosed && this.privSourceBuffer !== undefined && (this.privAudioBuffer.length === 0)\r\n            && this.privMediaSourceOpened && !this.privAppendingToBuffer && this.privMediaSource.readyState === \"open\");\r\n    }\r\n\r\n    private sourceBufferAvailable(): boolean {\r\n        return (this.privSourceBuffer !== undefined && !this.privSourceBuffer.updating);\r\n    }\r\n}\r\n"]}},"error":null,"hash":"77b999cee559fdfb0a0581688fec0591","cacheData":{"env":{}}}