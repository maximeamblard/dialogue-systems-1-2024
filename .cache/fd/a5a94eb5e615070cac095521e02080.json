{"id":"../node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Queue.js","dependencies":[{"name":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Queue.js.map","includedInParent":true,"mtime":1733074701821},{"name":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/package.json","includedInParent":true,"mtime":1733076065657},{"name":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/package.json","includedInParent":true,"mtime":1733074701821},{"name":"./Error","loc":{"line":42,"column":22,"index":2691},"parent":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Queue.js","resolved":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Error.js"},{"name":"./List","loc":{"line":43,"column":21,"index":2724},"parent":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Queue.js","resolved":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/List.js"},{"name":"./Promise","loc":{"line":44,"column":24,"index":2759},"parent":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Queue.js","resolved":"/Users/amblardv5/Nextcloud/2024/dialogue-systems-1-2024/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Promise.js"}],"generated":{"js":"\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Queue = void 0;\nvar Error_1 = require(\"./Error\");\nvar List_1 = require(\"./List\");\nvar Promise_1 = require(\"./Promise\");\nvar SubscriberType;\n(function (SubscriberType) {\n    SubscriberType[SubscriberType[\"Dequeue\"] = 0] = \"Dequeue\";\n    SubscriberType[SubscriberType[\"Peek\"] = 1] = \"Peek\";\n})(SubscriberType || (SubscriberType = {}));\nvar Queue = /** @class */ (function () {\n    function Queue(list) {\n        var _this = this;\n        this.privPromiseStore = new List_1.List();\n        this.privIsDrainInProgress = false;\n        this.privIsDisposing = false;\n        this.privDisposeReason = null;\n        this.privList = list ? list : new List_1.List();\n        this.privDetachables = [];\n        this.privSubscribers = new List_1.List();\n        this.privDetachables.push(this.privList.onAdded(function () { return _this.drain(); }));\n    }\n    Queue.prototype.enqueue = function (item) {\n        this.throwIfDispose();\n        this.enqueueFromPromise(new Promise(function (resolve) { return resolve(item); }));\n    };\n    Queue.prototype.enqueueFromPromise = function (promise) {\n        var _this = this;\n        this.throwIfDispose();\n        promise.then(function (val) {\n            _this.privList.add(val);\n            // eslint-disable-next-line @typescript-eslint/no-empty-function\n        }, function () { });\n    };\n    Queue.prototype.dequeue = function () {\n        this.throwIfDispose();\n        var deferredSubscriber = new Promise_1.Deferred();\n        if (this.privSubscribers) {\n            this.privSubscribers.add({ deferral: deferredSubscriber, type: SubscriberType.Dequeue });\n            this.drain();\n        }\n        return deferredSubscriber.promise;\n    };\n    Queue.prototype.peek = function () {\n        this.throwIfDispose();\n        var deferredSubscriber = new Promise_1.Deferred();\n        var subs = this.privSubscribers;\n        if (subs) {\n            this.privSubscribers.add({ deferral: deferredSubscriber, type: SubscriberType.Peek });\n            this.drain();\n        }\n        return deferredSubscriber.promise;\n    };\n    Queue.prototype.length = function () {\n        this.throwIfDispose();\n        return this.privList.length();\n    };\n    Queue.prototype.isDisposed = function () {\n        return this.privSubscribers == null;\n    };\n    Queue.prototype.drainAndDispose = function (pendingItemProcessor, reason) {\n        return __awaiter(this, void 0, void 0, function () {\n            var subs, subscriber, _i, _a, detachable, promiseArray_1;\n            var _this = this;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!(!this.isDisposed() && !this.privIsDisposing)) return [3 /*break*/, 5];\n                        this.privDisposeReason = reason;\n                        this.privIsDisposing = true;\n                        subs = this.privSubscribers;\n                        if (subs) {\n                            while (subs.length() > 0) {\n                                subscriber = subs.removeFirst();\n                                // TODO: this needs work (Resolve(null) instead?).\n                                subscriber.deferral.resolve(undefined);\n                                // subscriber.deferral.reject(\"Disposed\");\n                            }\n                            // note: this block assumes cooperative multitasking, i.e.,\n                            // between the if-statement and the assignment there are no\n                            // thread switches.\n                            // Reason is that between the initial const = this.; and this\n                            // point there is the derral.resolve() operation that might have\n                            // caused recursive calls to the Queue, especially, calling\n                            // Dispose() on the queue alredy (which would reset the var\n                            // here to null!).\n                            // That should generally hold true for javascript...\n                            if (this.privSubscribers === subs) {\n                                this.privSubscribers = subs;\n                            }\n                        }\n                        _i = 0, _a = this.privDetachables;\n                        _b.label = 1;\n                    case 1:\n                        if (!(_i < _a.length)) return [3 /*break*/, 4];\n                        detachable = _a[_i];\n                        return [4 /*yield*/, detachable.detach()];\n                    case 2:\n                        _b.sent();\n                        _b.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        if (this.privPromiseStore.length() > 0 && pendingItemProcessor) {\n                            promiseArray_1 = [];\n                            this.privPromiseStore.toArray().forEach(function (wrapper) {\n                                promiseArray_1.push(wrapper);\n                            });\n                            return [2 /*return*/, Promise.all(promiseArray_1).finally(function () {\n                                    _this.privSubscribers = null;\n                                    _this.privList.forEach(function (item) {\n                                        pendingItemProcessor(item);\n                                    });\n                                    _this.privList = null;\n                                    return;\n                                }).then()];\n                        }\n                        else {\n                            this.privSubscribers = null;\n                            this.privList = null;\n                        }\n                        _b.label = 5;\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Queue.prototype.dispose = function (reason) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.drainAndDispose(null, reason)];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Queue.prototype.drain = function () {\n        if (!this.privIsDrainInProgress && !this.privIsDisposing) {\n            this.privIsDrainInProgress = true;\n            var subs = this.privSubscribers;\n            var lists = this.privList;\n            if (subs && lists) {\n                while (lists.length() > 0 && subs.length() > 0 && !this.privIsDisposing) {\n                    var subscriber = subs.removeFirst();\n                    if (subscriber.type === SubscriberType.Peek) {\n                        subscriber.deferral.resolve(lists.first());\n                    }\n                    else {\n                        var dequeuedItem = lists.removeFirst();\n                        subscriber.deferral.resolve(dequeuedItem);\n                    }\n                }\n                // note: this block assumes cooperative multitasking, i.e.,\n                // between the if-statement and the assignment there are no\n                // thread switches.\n                // Reason is that between the initial const = this.; and this\n                // point there is the derral.resolve() operation that might have\n                // caused recursive calls to the Queue, especially, calling\n                // Dispose() on the queue alredy (which would reset the var\n                // here to null!).\n                // That should generally hold true for javascript...\n                if (this.privSubscribers === subs) {\n                    this.privSubscribers = subs;\n                }\n                // note: this block assumes cooperative multitasking, i.e.,\n                // between the if-statement and the assignment there are no\n                // thread switches.\n                // Reason is that between the initial const = this.; and this\n                // point there is the derral.resolve() operation that might have\n                // caused recursive calls to the Queue, especially, calling\n                // Dispose() on the queue alredy (which would reset the var\n                // here to null!).\n                // That should generally hold true for javascript...\n                if (this.privList === lists) {\n                    this.privList = lists;\n                }\n            }\n            this.privIsDrainInProgress = false;\n        }\n    };\n    Queue.prototype.throwIfDispose = function () {\n        if (this.isDisposed()) {\n            if (this.privDisposeReason) {\n                throw new Error_1.InvalidOperationError(this.privDisposeReason);\n            }\n            throw new Error_1.ObjectDisposedError(\"Queue\");\n        }\n        else if (this.privIsDisposing) {\n            throw new Error_1.InvalidOperationError(\"Queue disposing\");\n        }\n    };\n    return Queue;\n}());\nexports.Queue = Queue;\n\n\n"},"sourceMaps":{"js":{"version":3,"sources":["src/common/Queue.ts"],"names":[],"mappings":"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","file":"Queue.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { InvalidOperationError, ObjectDisposedError } from \"./Error\";\r\nimport { IDetachable } from \"./IDetachable\";\r\nimport { IDisposable } from \"./IDisposable\";\r\nimport { List } from \"./List\";\r\nimport {\r\n    Deferred,\r\n} from \"./Promise\";\r\nexport interface IQueue<TItem> extends IDisposable {\r\n    enqueue(item: TItem): void;\r\n    enqueueFromPromise(promise: Promise<TItem>): void;\r\n    dequeue(): Promise<TItem>;\r\n    peek(): Promise<TItem>;\r\n    length(): number;\r\n}\r\n\r\nenum SubscriberType {\r\n    Dequeue,\r\n    Peek,\r\n}\r\n\r\nexport class Queue<TItem> implements IQueue<TItem> {\r\n    private privPromiseStore: List<Promise<TItem>> = new List<Promise<TItem>>();\r\n    private privList: List<TItem>;\r\n    private privDetachables: IDetachable[];\r\n    private privSubscribers: List<{ type: SubscriberType; deferral: Deferred<TItem> }>;\r\n    private privIsDrainInProgress: boolean = false;\r\n    private privIsDisposing: boolean = false;\r\n    private privDisposeReason: string = null;\r\n\r\n    public constructor(list?: List<TItem>) {\r\n        this.privList = list ? list : new List<TItem>();\r\n        this.privDetachables = [];\r\n        this.privSubscribers = new List<{ type: SubscriberType; deferral: Deferred<TItem> }>();\r\n        this.privDetachables.push(this.privList.onAdded((): void => this.drain()));\r\n    }\r\n\r\n    public enqueue(item: TItem): void {\r\n        this.throwIfDispose();\r\n        this.enqueueFromPromise(new Promise<TItem>((resolve: (value: TItem) => void): void => resolve(item)));\r\n    }\r\n\r\n    public enqueueFromPromise(promise: Promise<TItem>): void {\r\n        this.throwIfDispose();\r\n        promise.then((val: TItem): void => {\r\n            this.privList.add(val);\r\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n        }, (): void => { });\r\n    }\r\n\r\n    public dequeue(): Promise<TItem> {\r\n        this.throwIfDispose();\r\n        const deferredSubscriber = new Deferred<TItem>();\r\n\r\n        if (this.privSubscribers) {\r\n            this.privSubscribers.add({ deferral: deferredSubscriber, type: SubscriberType.Dequeue });\r\n            this.drain();\r\n        }\r\n\r\n        return deferredSubscriber.promise;\r\n    }\r\n\r\n    public peek(): Promise<TItem> {\r\n        this.throwIfDispose();\r\n        const deferredSubscriber = new Deferred<TItem>();\r\n\r\n        const subs = this.privSubscribers;\r\n        if (subs) {\r\n            this.privSubscribers.add({ deferral: deferredSubscriber, type: SubscriberType.Peek });\r\n            this.drain();\r\n        }\r\n\r\n        return deferredSubscriber.promise;\r\n    }\r\n\r\n    public length(): number {\r\n        this.throwIfDispose();\r\n        return this.privList.length();\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return this.privSubscribers == null;\r\n    }\r\n\r\n    public async drainAndDispose(pendingItemProcessor: (pendingItemInQueue: TItem) => void, reason?: string): Promise<void> {\r\n        if (!this.isDisposed() && !this.privIsDisposing) {\r\n            this.privDisposeReason = reason;\r\n            this.privIsDisposing = true;\r\n\r\n            const subs = this.privSubscribers;\r\n            if (subs) {\r\n                while (subs.length() > 0) {\r\n                    const subscriber = subs.removeFirst();\r\n                    // TODO: this needs work (Resolve(null) instead?).\r\n                    subscriber.deferral.resolve(undefined);\r\n                    // subscriber.deferral.reject(\"Disposed\");\r\n                }\r\n\r\n                // note: this block assumes cooperative multitasking, i.e.,\r\n                // between the if-statement and the assignment there are no\r\n                // thread switches.\r\n                // Reason is that between the initial const = this.; and this\r\n                // point there is the derral.resolve() operation that might have\r\n                // caused recursive calls to the Queue, especially, calling\r\n                // Dispose() on the queue alredy (which would reset the var\r\n                // here to null!).\r\n                // That should generally hold true for javascript...\r\n                if (this.privSubscribers === subs) {\r\n                    this.privSubscribers = subs;\r\n                }\r\n            }\r\n\r\n            for (const detachable of this.privDetachables) {\r\n                await detachable.detach();\r\n            }\r\n\r\n            if (this.privPromiseStore.length() > 0 && pendingItemProcessor) {\r\n                const promiseArray: Promise<TItem>[] = [];\r\n\r\n                this.privPromiseStore.toArray().forEach((wrapper: Promise<TItem>): void => {\r\n                    promiseArray.push(wrapper);\r\n                });\r\n                return Promise.all(promiseArray).finally((): void => {\r\n                    this.privSubscribers = null;\r\n                    this.privList.forEach((item: TItem): void => {\r\n                        pendingItemProcessor(item);\r\n                    });\r\n                    this.privList = null;\r\n                    return;\r\n                }).then<void>();\r\n            } else {\r\n                this.privSubscribers = null;\r\n                this.privList = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    public async dispose(reason?: string): Promise<void> {\r\n        await this.drainAndDispose(null, reason);\r\n    }\r\n\r\n    private drain(): void {\r\n        if (!this.privIsDrainInProgress && !this.privIsDisposing) {\r\n            this.privIsDrainInProgress = true;\r\n\r\n            const subs = this.privSubscribers;\r\n            const lists = this.privList;\r\n            if (subs && lists) {\r\n                while (lists.length() > 0 && subs.length() > 0 && !this.privIsDisposing) {\r\n                    const subscriber = subs.removeFirst();\r\n                    if (subscriber.type === SubscriberType.Peek) {\r\n                        subscriber.deferral.resolve(lists.first());\r\n                    } else {\r\n                        const dequeuedItem = lists.removeFirst();\r\n                        subscriber.deferral.resolve(dequeuedItem);\r\n                    }\r\n                }\r\n\r\n                // note: this block assumes cooperative multitasking, i.e.,\r\n                // between the if-statement and the assignment there are no\r\n                // thread switches.\r\n                // Reason is that between the initial const = this.; and this\r\n                // point there is the derral.resolve() operation that might have\r\n                // caused recursive calls to the Queue, especially, calling\r\n                // Dispose() on the queue alredy (which would reset the var\r\n                // here to null!).\r\n                // That should generally hold true for javascript...\r\n                if (this.privSubscribers === subs) {\r\n                    this.privSubscribers = subs;\r\n                }\r\n\r\n                // note: this block assumes cooperative multitasking, i.e.,\r\n                // between the if-statement and the assignment there are no\r\n                // thread switches.\r\n                // Reason is that between the initial const = this.; and this\r\n                // point there is the derral.resolve() operation that might have\r\n                // caused recursive calls to the Queue, especially, calling\r\n                // Dispose() on the queue alredy (which would reset the var\r\n                // here to null!).\r\n                // That should generally hold true for javascript...\r\n                if (this.privList === lists) {\r\n                    this.privList = lists;\r\n                }\r\n            }\r\n\r\n            this.privIsDrainInProgress = false;\r\n        }\r\n    }\r\n\r\n    private throwIfDispose(): void {\r\n        if (this.isDisposed()) {\r\n            if (this.privDisposeReason) {\r\n                throw new InvalidOperationError(this.privDisposeReason);\r\n            }\r\n\r\n            throw new ObjectDisposedError(\"Queue\");\r\n        } else if (this.privIsDisposing) {\r\n            throw new InvalidOperationError(\"Queue disposing\");\r\n        }\r\n    }\r\n}\r\n"]}},"error":null,"hash":"f2bf93b8c0335cf08d44b7e81b047a3f","cacheData":{"env":{}}}